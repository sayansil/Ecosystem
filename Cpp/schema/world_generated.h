// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORLD_ECOSYSTEM_H_
#define FLATBUFFERS_GENERATED_WORLD_ECOSYSTEM_H_

#include "flatbuffers/flatbuffers.h"

namespace Ecosystem {

struct ChromosomeStrand;
struct ChromosomeStrandBuilder;

struct Organism;
struct OrganismBuilder;

struct Species;
struct SpeciesBuilder;

struct World;
struct WorldBuilder;

inline const flatbuffers::TypeTable *ChromosomeStrandTypeTable();

inline const flatbuffers::TypeTable *OrganismTypeTable();

inline const flatbuffers::TypeTable *SpeciesTypeTable();

inline const flatbuffers::TypeTable *WorldTypeTable();

enum class Gender : uint8_t {
  Male = 0,
  Female = 1,
  MIN = Male,
  MAX = Female
};

inline const Gender (&EnumValuesGender())[2] {
  static const Gender values[] = {
    Gender::Male,
    Gender::Female
  };
  return values;
}

inline const char * const *EnumNamesGender() {
  static const char * const names[3] = {
    "Male",
    "Female",
    nullptr
  };
  return names;
}

inline const char *EnumNameGender(Gender e) {
  if (flatbuffers::IsOutRange(e, Gender::Male, Gender::Female)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGender()[index];
}

enum class Reproduction : uint8_t {
  Sexual = 0,
  Asexual = 1,
  MIN = Sexual,
  MAX = Asexual
};

inline const Reproduction (&EnumValuesReproduction())[2] {
  static const Reproduction values[] = {
    Reproduction::Sexual,
    Reproduction::Asexual
  };
  return values;
}

inline const char * const *EnumNamesReproduction() {
  static const char * const names[3] = {
    "Sexual",
    "Asexual",
    nullptr
  };
  return names;
}

inline const char *EnumNameReproduction(Reproduction e) {
  if (flatbuffers::IsOutRange(e, Reproduction::Sexual, Reproduction::Asexual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReproduction()[index];
}

enum class Monitor : uint8_t {
  None = 0,
  Simulation = 1,
  MIN = None,
  MAX = Simulation
};

inline const Monitor (&EnumValuesMonitor())[2] {
  static const Monitor values[] = {
    Monitor::None,
    Monitor::Simulation
  };
  return values;
}

inline const char * const *EnumNamesMonitor() {
  static const char * const names[3] = {
    "None",
    "Simulation",
    nullptr
  };
  return names;
}

inline const char *EnumNameMonitor(Monitor e) {
  if (flatbuffers::IsOutRange(e, Monitor::None, Monitor::Simulation)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMonitor()[index];
}

enum class Sleep : uint8_t {
  Awake = 0,
  Drowsy = 1,
  Asleep = 2,
  MIN = Awake,
  MAX = Asleep
};

inline const Sleep (&EnumValuesSleep())[3] {
  static const Sleep values[] = {
    Sleep::Awake,
    Sleep::Drowsy,
    Sleep::Asleep
  };
  return values;
}

inline const char * const *EnumNamesSleep() {
  static const char * const names[4] = {
    "Awake",
    "Drowsy",
    "Asleep",
    nullptr
  };
  return names;
}

inline const char *EnumNameSleep(Sleep e) {
  if (flatbuffers::IsOutRange(e, Sleep::Awake, Sleep::Asleep)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSleep()[index];
}

enum class KingdomE : uint8_t {
  Animal = 0,
  Plant = 1,
  MIN = Animal,
  MAX = Plant
};

inline const KingdomE (&EnumValuesKingdomE())[2] {
  static const KingdomE values[] = {
    KingdomE::Animal,
    KingdomE::Plant
  };
  return values;
}

inline const char * const *EnumNamesKingdomE() {
  static const char * const names[3] = {
    "Animal",
    "Plant",
    nullptr
  };
  return names;
}

inline const char *EnumNameKingdomE(KingdomE e) {
  if (flatbuffers::IsOutRange(e, KingdomE::Animal, KingdomE::Plant)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKingdomE()[index];
}

struct ChromosomeStrand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChromosomeStrandBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChromosomeStrandTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_START = 6,
    VT_LENGTH = 8
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  flatbuffers::String *mutable_code() {
    return GetPointer<flatbuffers::String *>(VT_CODE);
  }
  bool KeyCompareLessThan(const ChromosomeStrand *o) const {
    return *code() < *o->code();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(code()->c_str(), val);
  }
  uint16_t start() const {
    return GetField<uint16_t>(VT_START, 0);
  }
  bool mutate_start(uint16_t _start = 0) {
    return SetField<uint16_t>(VT_START, _start, 0);
  }
  uint16_t length() const {
    return GetField<uint16_t>(VT_LENGTH, 0);
  }
  bool mutate_length(uint16_t _length = 0) {
    return SetField<uint16_t>(VT_LENGTH, _length, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyField<uint16_t>(verifier, VT_START) &&
           VerifyField<uint16_t>(verifier, VT_LENGTH) &&
           verifier.EndTable();
  }
};

struct ChromosomeStrandBuilder {
  typedef ChromosomeStrand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(ChromosomeStrand::VT_CODE, code);
  }
  void add_start(uint16_t start) {
    fbb_.AddElement<uint16_t>(ChromosomeStrand::VT_START, start, 0);
  }
  void add_length(uint16_t length) {
    fbb_.AddElement<uint16_t>(ChromosomeStrand::VT_LENGTH, length, 0);
  }
  explicit ChromosomeStrandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChromosomeStrand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChromosomeStrand>(end);
    fbb_.Required(o, ChromosomeStrand::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<ChromosomeStrand> CreateChromosomeStrand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    uint16_t start = 0,
    uint16_t length = 0) {
  ChromosomeStrandBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_length(length);
  builder_.add_start(start);
  return builder_.Finish();
}

struct ChromosomeStrand::Traits {
  using type = ChromosomeStrand;
  static auto constexpr Create = CreateChromosomeStrand;
};

inline flatbuffers::Offset<ChromosomeStrand> CreateChromosomeStrandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    uint16_t start = 0,
    uint16_t length = 0) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  return Ecosystem::CreateChromosomeStrand(
      _fbb,
      code__,
      start,
      length);
}

struct Organism FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrganismBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OrganismTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4,
    VT_KINGDOM = 6,
    VT_CHROMOSOME_NUMBER = 8,
    VT_MONITOR = 10,
    VT_CHROMOSOME_STRUCTURE = 12,
    VT_FOOD_CHAIN_RANK = 14,
    VT_IS_ASEXUAL = 16,
    VT_AGE_FITNESS_ON_DEATH_RATIO = 18,
    VT_CONCEIVING_PROBABILITY = 20,
    VT_MATING_PROBABILITY = 22,
    VT_MATING_AGE_START = 24,
    VT_MATING_AGE_END = 26,
    VT_MAX_AGE = 28,
    VT_MUTATION_PROBABILITY = 30,
    VT_OFFSPRINGS_FACTOR = 32,
    VT_HEIGHT_ON_SPEED = 34,
    VT_HEIGHT_ON_STAMINA = 36,
    VT_HEIGHT_ON_VITALITY = 38,
    VT_WEIGHT_ON_SPEED = 40,
    VT_WEIGHT_ON_STAMINA = 42,
    VT_WEIGHT_ON_VITALITY = 44,
    VT_VITALITY_ON_APPETITE = 46,
    VT_VITALITY_ON_SPEED = 48,
    VT_STAMINA_ON_APPETITE = 50,
    VT_STAMINA_ON_SPEED = 52,
    VT_THEORETICAL_MAXIMUM_BASE_APPETITE = 54,
    VT_THEORETICAL_MAXIMUM_BASE_HEIGHT = 56,
    VT_THEORETICAL_MAXIMUM_BASE_SPEED = 58,
    VT_THEORETICAL_MAXIMUM_BASE_STAMINA = 60,
    VT_THEORETICAL_MAXIMUM_BASE_VITALITY = 62,
    VT_THEORETICAL_MAXIMUM_BASE_WEIGHT = 64,
    VT_THEORETICAL_MAXIMUM_HEIGHT = 66,
    VT_THEORETICAL_MAXIMUM_SPEED = 68,
    VT_THEORETICAL_MAXIMUM_WEIGHT = 70,
    VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER = 72,
    VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER = 74,
    VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER = 76,
    VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER = 78,
    VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER = 80,
    VT_NAME = 82,
    VT_CHROMOSOME = 84,
    VT_GENDER = 86,
    VT_GENERATION = 88,
    VT_IMMUNITY = 90,
    VT_BASE_APPETITE = 92,
    VT_BASE_HEIGHT = 94,
    VT_BASE_SPEED = 96,
    VT_BASE_STAMINA = 98,
    VT_BASE_VITALITY = 100,
    VT_BASE_WEIGHT = 102,
    VT_HEIGHT_MULTIPLIER = 104,
    VT_SPEED_MULTIPLIER = 106,
    VT_STAMINA_MULTIPLIER = 108,
    VT_VITALITY_MULTIPLIER = 110,
    VT_WEIGHT_MULTIPLIER = 112,
    VT_MAX_HEIGHT = 114,
    VT_MAX_WEIGHT = 116,
    VT_AGE = 118,
    VT_HEIGHT = 120,
    VT_WEIGHT = 122,
    VT_AGE_DEATH_FACTOR = 124,
    VT_FITNESS_DEATH_FACTOR = 126,
    VT_DEATH_FACTOR = 128,
    VT_STATIC_FITNESS = 130,
    VT_MAX_APPETITE_AT_AGE = 132,
    VT_MAX_SPEED_AT_AGE = 134,
    VT_MAX_STAMINA_AT_AGE = 136,
    VT_MAX_VITALITY_AT_AGE = 138,
    VT_APPETITE = 140,
    VT_SPEED = 142,
    VT_STAMINA = 144,
    VT_VITALITY = 146,
    VT_X = 148,
    VT_Y = 150,
    VT_DYNAMIC_FITNESS = 152,
    VT_VISION_RADIUS = 154,
    VT_SLEEP_RESTORE_FACTOR = 156,
    VT_ASLEEP = 158
  };
  /// Fixed for a species
  const flatbuffers::String *kind() const {
    return GetPointer<const flatbuffers::String *>(VT_KIND);
  }
  flatbuffers::String *mutable_kind() {
    return GetPointer<flatbuffers::String *>(VT_KIND);
  }
  Ecosystem::KingdomE kingdom() const {
    return static_cast<Ecosystem::KingdomE>(GetField<uint8_t>(VT_KINGDOM, 0));
  }
  bool mutate_kingdom(Ecosystem::KingdomE _kingdom = static_cast<Ecosystem::KingdomE>(0)) {
    return SetField<uint8_t>(VT_KINGDOM, static_cast<uint8_t>(_kingdom), 0);
  }
  uint16_t chromosome_number() const {
    return GetField<uint16_t>(VT_CHROMOSOME_NUMBER, 0);
  }
  bool mutate_chromosome_number(uint16_t _chromosome_number = 0) {
    return SetField<uint16_t>(VT_CHROMOSOME_NUMBER, _chromosome_number, 0);
  }
  Ecosystem::Monitor monitor() const {
    return static_cast<Ecosystem::Monitor>(GetField<uint8_t>(VT_MONITOR, 0));
  }
  bool mutate_monitor(Ecosystem::Monitor _monitor = static_cast<Ecosystem::Monitor>(0)) {
    return SetField<uint8_t>(VT_MONITOR, static_cast<uint8_t>(_monitor), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *chromosome_structure() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *>(VT_CHROMOSOME_STRUCTURE);
  }
  flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *mutable_chromosome_structure() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *>(VT_CHROMOSOME_STRUCTURE);
  }
  uint8_t food_chain_rank() const {
    return GetField<uint8_t>(VT_FOOD_CHAIN_RANK, 0);
  }
  bool mutate_food_chain_rank(uint8_t _food_chain_rank = 0) {
    return SetField<uint8_t>(VT_FOOD_CHAIN_RANK, _food_chain_rank, 0);
  }
  Ecosystem::Reproduction is_asexual() const {
    return static_cast<Ecosystem::Reproduction>(GetField<uint8_t>(VT_IS_ASEXUAL, 0));
  }
  bool mutate_is_asexual(Ecosystem::Reproduction _is_asexual = static_cast<Ecosystem::Reproduction>(0)) {
    return SetField<uint8_t>(VT_IS_ASEXUAL, static_cast<uint8_t>(_is_asexual), 0);
  }
  float age_fitness_on_death_ratio() const {
    return GetField<float>(VT_AGE_FITNESS_ON_DEATH_RATIO, 0.0f);
  }
  bool mutate_age_fitness_on_death_ratio(float _age_fitness_on_death_ratio = 0.0f) {
    return SetField<float>(VT_AGE_FITNESS_ON_DEATH_RATIO, _age_fitness_on_death_ratio, 0.0f);
  }
  float conceiving_probability() const {
    return GetField<float>(VT_CONCEIVING_PROBABILITY, 0.0f);
  }
  bool mutate_conceiving_probability(float _conceiving_probability = 0.0f) {
    return SetField<float>(VT_CONCEIVING_PROBABILITY, _conceiving_probability, 0.0f);
  }
  float mating_probability() const {
    return GetField<float>(VT_MATING_PROBABILITY, 0.0f);
  }
  bool mutate_mating_probability(float _mating_probability = 0.0f) {
    return SetField<float>(VT_MATING_PROBABILITY, _mating_probability, 0.0f);
  }
  uint32_t mating_age_start() const {
    return GetField<uint32_t>(VT_MATING_AGE_START, 0);
  }
  bool mutate_mating_age_start(uint32_t _mating_age_start = 0) {
    return SetField<uint32_t>(VT_MATING_AGE_START, _mating_age_start, 0);
  }
  uint32_t mating_age_end() const {
    return GetField<uint32_t>(VT_MATING_AGE_END, 0);
  }
  bool mutate_mating_age_end(uint32_t _mating_age_end = 0) {
    return SetField<uint32_t>(VT_MATING_AGE_END, _mating_age_end, 0);
  }
  uint32_t max_age() const {
    return GetField<uint32_t>(VT_MAX_AGE, 0);
  }
  bool mutate_max_age(uint32_t _max_age = 0) {
    return SetField<uint32_t>(VT_MAX_AGE, _max_age, 0);
  }
  float mutation_probability() const {
    return GetField<float>(VT_MUTATION_PROBABILITY, 0.0f);
  }
  bool mutate_mutation_probability(float _mutation_probability = 0.0f) {
    return SetField<float>(VT_MUTATION_PROBABILITY, _mutation_probability, 0.0f);
  }
  float offsprings_factor() const {
    return GetField<float>(VT_OFFSPRINGS_FACTOR, 0.0f);
  }
  bool mutate_offsprings_factor(float _offsprings_factor = 0.0f) {
    return SetField<float>(VT_OFFSPRINGS_FACTOR, _offsprings_factor, 0.0f);
  }
  float height_on_speed() const {
    return GetField<float>(VT_HEIGHT_ON_SPEED, 0.0f);
  }
  bool mutate_height_on_speed(float _height_on_speed = 0.0f) {
    return SetField<float>(VT_HEIGHT_ON_SPEED, _height_on_speed, 0.0f);
  }
  float height_on_stamina() const {
    return GetField<float>(VT_HEIGHT_ON_STAMINA, 0.0f);
  }
  bool mutate_height_on_stamina(float _height_on_stamina = 0.0f) {
    return SetField<float>(VT_HEIGHT_ON_STAMINA, _height_on_stamina, 0.0f);
  }
  float height_on_vitality() const {
    return GetField<float>(VT_HEIGHT_ON_VITALITY, 0.0f);
  }
  bool mutate_height_on_vitality(float _height_on_vitality = 0.0f) {
    return SetField<float>(VT_HEIGHT_ON_VITALITY, _height_on_vitality, 0.0f);
  }
  float weight_on_speed() const {
    return GetField<float>(VT_WEIGHT_ON_SPEED, 0.0f);
  }
  bool mutate_weight_on_speed(float _weight_on_speed = 0.0f) {
    return SetField<float>(VT_WEIGHT_ON_SPEED, _weight_on_speed, 0.0f);
  }
  float weight_on_stamina() const {
    return GetField<float>(VT_WEIGHT_ON_STAMINA, 0.0f);
  }
  bool mutate_weight_on_stamina(float _weight_on_stamina = 0.0f) {
    return SetField<float>(VT_WEIGHT_ON_STAMINA, _weight_on_stamina, 0.0f);
  }
  float weight_on_vitality() const {
    return GetField<float>(VT_WEIGHT_ON_VITALITY, 0.0f);
  }
  bool mutate_weight_on_vitality(float _weight_on_vitality = 0.0f) {
    return SetField<float>(VT_WEIGHT_ON_VITALITY, _weight_on_vitality, 0.0f);
  }
  float vitality_on_appetite() const {
    return GetField<float>(VT_VITALITY_ON_APPETITE, 0.0f);
  }
  bool mutate_vitality_on_appetite(float _vitality_on_appetite = 0.0f) {
    return SetField<float>(VT_VITALITY_ON_APPETITE, _vitality_on_appetite, 0.0f);
  }
  float vitality_on_speed() const {
    return GetField<float>(VT_VITALITY_ON_SPEED, 0.0f);
  }
  bool mutate_vitality_on_speed(float _vitality_on_speed = 0.0f) {
    return SetField<float>(VT_VITALITY_ON_SPEED, _vitality_on_speed, 0.0f);
  }
  float stamina_on_appetite() const {
    return GetField<float>(VT_STAMINA_ON_APPETITE, 0.0f);
  }
  bool mutate_stamina_on_appetite(float _stamina_on_appetite = 0.0f) {
    return SetField<float>(VT_STAMINA_ON_APPETITE, _stamina_on_appetite, 0.0f);
  }
  float stamina_on_speed() const {
    return GetField<float>(VT_STAMINA_ON_SPEED, 0.0f);
  }
  bool mutate_stamina_on_speed(float _stamina_on_speed = 0.0f) {
    return SetField<float>(VT_STAMINA_ON_SPEED, _stamina_on_speed, 0.0f);
  }
  float theoretical_maximum_base_appetite() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_APPETITE, 0.0f);
  }
  bool mutate_theoretical_maximum_base_appetite(float _theoretical_maximum_base_appetite = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_APPETITE, _theoretical_maximum_base_appetite, 0.0f);
  }
  float theoretical_maximum_base_height() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_HEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_base_height(float _theoretical_maximum_base_height = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_HEIGHT, _theoretical_maximum_base_height, 0.0f);
  }
  float theoretical_maximum_base_speed() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_SPEED, 0.0f);
  }
  bool mutate_theoretical_maximum_base_speed(float _theoretical_maximum_base_speed = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_SPEED, _theoretical_maximum_base_speed, 0.0f);
  }
  float theoretical_maximum_base_stamina() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_STAMINA, 0.0f);
  }
  bool mutate_theoretical_maximum_base_stamina(float _theoretical_maximum_base_stamina = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_STAMINA, _theoretical_maximum_base_stamina, 0.0f);
  }
  float theoretical_maximum_base_vitality() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_VITALITY, 0.0f);
  }
  bool mutate_theoretical_maximum_base_vitality(float _theoretical_maximum_base_vitality = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_VITALITY, _theoretical_maximum_base_vitality, 0.0f);
  }
  float theoretical_maximum_base_weight() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_WEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_base_weight(float _theoretical_maximum_base_weight = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_WEIGHT, _theoretical_maximum_base_weight, 0.0f);
  }
  float theoretical_maximum_height() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_height(float _theoretical_maximum_height = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT, _theoretical_maximum_height, 0.0f);
  }
  float theoretical_maximum_speed() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_SPEED, 0.0f);
  }
  bool mutate_theoretical_maximum_speed(float _theoretical_maximum_speed = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_SPEED, _theoretical_maximum_speed, 0.0f);
  }
  float theoretical_maximum_weight() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_weight(float _theoretical_maximum_weight = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT, _theoretical_maximum_weight, 0.0f);
  }
  float theoretical_maximum_height_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_height_multiplier(float _theoretical_maximum_height_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER, _theoretical_maximum_height_multiplier, 0.0f);
  }
  float theoretical_maximum_speed_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_speed_multiplier(float _theoretical_maximum_speed_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER, _theoretical_maximum_speed_multiplier, 0.0f);
  }
  float theoretical_maximum_stamina_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_stamina_multiplier(float _theoretical_maximum_stamina_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER, _theoretical_maximum_stamina_multiplier, 0.0f);
  }
  float theoretical_maximum_vitality_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_vitality_multiplier(float _theoretical_maximum_vitality_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER, _theoretical_maximum_vitality_multiplier, 0.0f);
  }
  float theoretical_maximum_weight_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_weight_multiplier(float _theoretical_maximum_weight_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER, _theoretical_maximum_weight_multiplier, 0.0f);
  }
  ///  Fixed for an organism
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Organism *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(name()->c_str(), val);
  }
  const flatbuffers::Vector<uint8_t> *chromosome() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CHROMOSOME);
  }
  flatbuffers::Vector<uint8_t> *mutable_chromosome() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CHROMOSOME);
  }
  Ecosystem::Gender gender() const {
    return static_cast<Ecosystem::Gender>(GetField<uint8_t>(VT_GENDER, 0));
  }
  bool mutate_gender(Ecosystem::Gender _gender = static_cast<Ecosystem::Gender>(0)) {
    return SetField<uint8_t>(VT_GENDER, static_cast<uint8_t>(_gender), 0);
  }
  uint32_t generation() const {
    return GetField<uint32_t>(VT_GENERATION, 0);
  }
  bool mutate_generation(uint32_t _generation = 0) {
    return SetField<uint32_t>(VT_GENERATION, _generation, 0);
  }
  float immunity() const {
    return GetField<float>(VT_IMMUNITY, 0.0f);
  }
  bool mutate_immunity(float _immunity = 0.0f) {
    return SetField<float>(VT_IMMUNITY, _immunity, 0.0f);
  }
  float base_appetite() const {
    return GetField<float>(VT_BASE_APPETITE, 0.0f);
  }
  bool mutate_base_appetite(float _base_appetite = 0.0f) {
    return SetField<float>(VT_BASE_APPETITE, _base_appetite, 0.0f);
  }
  float base_height() const {
    return GetField<float>(VT_BASE_HEIGHT, 0.0f);
  }
  bool mutate_base_height(float _base_height = 0.0f) {
    return SetField<float>(VT_BASE_HEIGHT, _base_height, 0.0f);
  }
  float base_speed() const {
    return GetField<float>(VT_BASE_SPEED, 0.0f);
  }
  bool mutate_base_speed(float _base_speed = 0.0f) {
    return SetField<float>(VT_BASE_SPEED, _base_speed, 0.0f);
  }
  float base_stamina() const {
    return GetField<float>(VT_BASE_STAMINA, 0.0f);
  }
  bool mutate_base_stamina(float _base_stamina = 0.0f) {
    return SetField<float>(VT_BASE_STAMINA, _base_stamina, 0.0f);
  }
  float base_vitality() const {
    return GetField<float>(VT_BASE_VITALITY, 0.0f);
  }
  bool mutate_base_vitality(float _base_vitality = 0.0f) {
    return SetField<float>(VT_BASE_VITALITY, _base_vitality, 0.0f);
  }
  float base_weight() const {
    return GetField<float>(VT_BASE_WEIGHT, 0.0f);
  }
  bool mutate_base_weight(float _base_weight = 0.0f) {
    return SetField<float>(VT_BASE_WEIGHT, _base_weight, 0.0f);
  }
  float height_multiplier() const {
    return GetField<float>(VT_HEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_height_multiplier(float _height_multiplier = 0.0f) {
    return SetField<float>(VT_HEIGHT_MULTIPLIER, _height_multiplier, 0.0f);
  }
  float speed_multiplier() const {
    return GetField<float>(VT_SPEED_MULTIPLIER, 0.0f);
  }
  bool mutate_speed_multiplier(float _speed_multiplier = 0.0f) {
    return SetField<float>(VT_SPEED_MULTIPLIER, _speed_multiplier, 0.0f);
  }
  float stamina_multiplier() const {
    return GetField<float>(VT_STAMINA_MULTIPLIER, 0.0f);
  }
  bool mutate_stamina_multiplier(float _stamina_multiplier = 0.0f) {
    return SetField<float>(VT_STAMINA_MULTIPLIER, _stamina_multiplier, 0.0f);
  }
  float vitality_multiplier() const {
    return GetField<float>(VT_VITALITY_MULTIPLIER, 0.0f);
  }
  bool mutate_vitality_multiplier(float _vitality_multiplier = 0.0f) {
    return SetField<float>(VT_VITALITY_MULTIPLIER, _vitality_multiplier, 0.0f);
  }
  float weight_multiplier() const {
    return GetField<float>(VT_WEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_weight_multiplier(float _weight_multiplier = 0.0f) {
    return SetField<float>(VT_WEIGHT_MULTIPLIER, _weight_multiplier, 0.0f);
  }
  float max_height() const {
    return GetField<float>(VT_MAX_HEIGHT, 0.0f);
  }
  bool mutate_max_height(float _max_height = 0.0f) {
    return SetField<float>(VT_MAX_HEIGHT, _max_height, 0.0f);
  }
  float max_weight() const {
    return GetField<float>(VT_MAX_WEIGHT, 0.0f);
  }
  bool mutate_max_weight(float _max_weight = 0.0f) {
    return SetField<float>(VT_MAX_WEIGHT, _max_weight, 0.0f);
  }
  /// Stats affected by age
  uint32_t age() const {
    return GetField<uint32_t>(VT_AGE, 0);
  }
  bool mutate_age(uint32_t _age = 0) {
    return SetField<uint32_t>(VT_AGE, _age, 0);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  bool mutate_height(float _height = 0.0f) {
    return SetField<float>(VT_HEIGHT, _height, 0.0f);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool mutate_weight(float _weight = 0.0f) {
    return SetField<float>(VT_WEIGHT, _weight, 0.0f);
  }
  float age_death_factor() const {
    return GetField<float>(VT_AGE_DEATH_FACTOR, 0.0f);
  }
  bool mutate_age_death_factor(float _age_death_factor = 0.0f) {
    return SetField<float>(VT_AGE_DEATH_FACTOR, _age_death_factor, 0.0f);
  }
  float fitness_death_factor() const {
    return GetField<float>(VT_FITNESS_DEATH_FACTOR, 0.0f);
  }
  bool mutate_fitness_death_factor(float _fitness_death_factor = 0.0f) {
    return SetField<float>(VT_FITNESS_DEATH_FACTOR, _fitness_death_factor, 0.0f);
  }
  float death_factor() const {
    return GetField<float>(VT_DEATH_FACTOR, 0.0f);
  }
  bool mutate_death_factor(float _death_factor = 0.0f) {
    return SetField<float>(VT_DEATH_FACTOR, _death_factor, 0.0f);
  }
  float static_fitness() const {
    return GetField<float>(VT_STATIC_FITNESS, 0.0f);
  }
  bool mutate_static_fitness(float _static_fitness = 0.0f) {
    return SetField<float>(VT_STATIC_FITNESS, _static_fitness, 0.0f);
  }
  float max_appetite_at_age() const {
    return GetField<float>(VT_MAX_APPETITE_AT_AGE, 0.0f);
  }
  bool mutate_max_appetite_at_age(float _max_appetite_at_age = 0.0f) {
    return SetField<float>(VT_MAX_APPETITE_AT_AGE, _max_appetite_at_age, 0.0f);
  }
  float max_speed_at_age() const {
    return GetField<float>(VT_MAX_SPEED_AT_AGE, 0.0f);
  }
  bool mutate_max_speed_at_age(float _max_speed_at_age = 0.0f) {
    return SetField<float>(VT_MAX_SPEED_AT_AGE, _max_speed_at_age, 0.0f);
  }
  float max_stamina_at_age() const {
    return GetField<float>(VT_MAX_STAMINA_AT_AGE, 0.0f);
  }
  bool mutate_max_stamina_at_age(float _max_stamina_at_age = 0.0f) {
    return SetField<float>(VT_MAX_STAMINA_AT_AGE, _max_stamina_at_age, 0.0f);
  }
  float max_vitality_at_age() const {
    return GetField<float>(VT_MAX_VITALITY_AT_AGE, 0.0f);
  }
  bool mutate_max_vitality_at_age(float _max_vitality_at_age = 0.0f) {
    return SetField<float>(VT_MAX_VITALITY_AT_AGE, _max_vitality_at_age, 0.0f);
  }
  float appetite() const {
    return GetField<float>(VT_APPETITE, 0.0f);
  }
  bool mutate_appetite(float _appetite = 0.0f) {
    return SetField<float>(VT_APPETITE, _appetite, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool mutate_speed(float _speed = 0.0f) {
    return SetField<float>(VT_SPEED, _speed, 0.0f);
  }
  float stamina() const {
    return GetField<float>(VT_STAMINA, 0.0f);
  }
  bool mutate_stamina(float _stamina = 0.0f) {
    return SetField<float>(VT_STAMINA, _stamina, 0.0f);
  }
  float vitality() const {
    return GetField<float>(VT_VITALITY, 0.0f);
  }
  bool mutate_vitality(float _vitality = 0.0f) {
    return SetField<float>(VT_VITALITY, _vitality, 0.0f);
  }
  uint64_t X() const {
    return GetField<uint64_t>(VT_X, 0);
  }
  bool mutate_X(uint64_t _X = 0) {
    return SetField<uint64_t>(VT_X, _X, 0);
  }
  uint64_t Y() const {
    return GetField<uint64_t>(VT_Y, 0);
  }
  bool mutate_Y(uint64_t _Y = 0) {
    return SetField<uint64_t>(VT_Y, _Y, 0);
  }
  float dynamic_fitness() const {
    return GetField<float>(VT_DYNAMIC_FITNESS, 0.0f);
  }
  bool mutate_dynamic_fitness(float _dynamic_fitness = 0.0f) {
    return SetField<float>(VT_DYNAMIC_FITNESS, _dynamic_fitness, 0.0f);
  }
  /// Miscellaneous attributes
  float vision_radius() const {
    return GetField<float>(VT_VISION_RADIUS, 0.0f);
  }
  bool mutate_vision_radius(float _vision_radius = 0.0f) {
    return SetField<float>(VT_VISION_RADIUS, _vision_radius, 0.0f);
  }
  float sleep_restore_factor() const {
    return GetField<float>(VT_SLEEP_RESTORE_FACTOR, 0.0f);
  }
  bool mutate_sleep_restore_factor(float _sleep_restore_factor = 0.0f) {
    return SetField<float>(VT_SLEEP_RESTORE_FACTOR, _sleep_restore_factor, 0.0f);
  }
  Ecosystem::Sleep asleep() const {
    return static_cast<Ecosystem::Sleep>(GetField<uint8_t>(VT_ASLEEP, 0));
  }
  bool mutate_asleep(Ecosystem::Sleep _asleep = static_cast<Ecosystem::Sleep>(0)) {
    return SetField<uint8_t>(VT_ASLEEP, static_cast<uint8_t>(_asleep), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KIND) &&
           verifier.VerifyString(kind()) &&
           VerifyField<uint8_t>(verifier, VT_KINGDOM) &&
           VerifyField<uint16_t>(verifier, VT_CHROMOSOME_NUMBER) &&
           VerifyField<uint8_t>(verifier, VT_MONITOR) &&
           VerifyOffset(verifier, VT_CHROMOSOME_STRUCTURE) &&
           verifier.VerifyVector(chromosome_structure()) &&
           verifier.VerifyVectorOfTables(chromosome_structure()) &&
           VerifyField<uint8_t>(verifier, VT_FOOD_CHAIN_RANK) &&
           VerifyField<uint8_t>(verifier, VT_IS_ASEXUAL) &&
           VerifyField<float>(verifier, VT_AGE_FITNESS_ON_DEATH_RATIO) &&
           VerifyField<float>(verifier, VT_CONCEIVING_PROBABILITY) &&
           VerifyField<float>(verifier, VT_MATING_PROBABILITY) &&
           VerifyField<uint32_t>(verifier, VT_MATING_AGE_START) &&
           VerifyField<uint32_t>(verifier, VT_MATING_AGE_END) &&
           VerifyField<uint32_t>(verifier, VT_MAX_AGE) &&
           VerifyField<float>(verifier, VT_MUTATION_PROBABILITY) &&
           VerifyField<float>(verifier, VT_OFFSPRINGS_FACTOR) &&
           VerifyField<float>(verifier, VT_HEIGHT_ON_SPEED) &&
           VerifyField<float>(verifier, VT_HEIGHT_ON_STAMINA) &&
           VerifyField<float>(verifier, VT_HEIGHT_ON_VITALITY) &&
           VerifyField<float>(verifier, VT_WEIGHT_ON_SPEED) &&
           VerifyField<float>(verifier, VT_WEIGHT_ON_STAMINA) &&
           VerifyField<float>(verifier, VT_WEIGHT_ON_VITALITY) &&
           VerifyField<float>(verifier, VT_VITALITY_ON_APPETITE) &&
           VerifyField<float>(verifier, VT_VITALITY_ON_SPEED) &&
           VerifyField<float>(verifier, VT_STAMINA_ON_APPETITE) &&
           VerifyField<float>(verifier, VT_STAMINA_ON_SPEED) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_APPETITE) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_HEIGHT) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_SPEED) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_STAMINA) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_VITALITY) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_WEIGHT) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_HEIGHT) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_SPEED) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_WEIGHT) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CHROMOSOME) &&
           verifier.VerifyVector(chromosome()) &&
           VerifyField<uint8_t>(verifier, VT_GENDER) &&
           VerifyField<uint32_t>(verifier, VT_GENERATION) &&
           VerifyField<float>(verifier, VT_IMMUNITY) &&
           VerifyField<float>(verifier, VT_BASE_APPETITE) &&
           VerifyField<float>(verifier, VT_BASE_HEIGHT) &&
           VerifyField<float>(verifier, VT_BASE_SPEED) &&
           VerifyField<float>(verifier, VT_BASE_STAMINA) &&
           VerifyField<float>(verifier, VT_BASE_VITALITY) &&
           VerifyField<float>(verifier, VT_BASE_WEIGHT) &&
           VerifyField<float>(verifier, VT_HEIGHT_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_SPEED_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_STAMINA_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_VITALITY_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_WEIGHT_MULTIPLIER) &&
           VerifyField<float>(verifier, VT_MAX_HEIGHT) &&
           VerifyField<float>(verifier, VT_MAX_WEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_AGE) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_WEIGHT) &&
           VerifyField<float>(verifier, VT_AGE_DEATH_FACTOR) &&
           VerifyField<float>(verifier, VT_FITNESS_DEATH_FACTOR) &&
           VerifyField<float>(verifier, VT_DEATH_FACTOR) &&
           VerifyField<float>(verifier, VT_STATIC_FITNESS) &&
           VerifyField<float>(verifier, VT_MAX_APPETITE_AT_AGE) &&
           VerifyField<float>(verifier, VT_MAX_SPEED_AT_AGE) &&
           VerifyField<float>(verifier, VT_MAX_STAMINA_AT_AGE) &&
           VerifyField<float>(verifier, VT_MAX_VITALITY_AT_AGE) &&
           VerifyField<float>(verifier, VT_APPETITE) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<float>(verifier, VT_STAMINA) &&
           VerifyField<float>(verifier, VT_VITALITY) &&
           VerifyField<uint64_t>(verifier, VT_X) &&
           VerifyField<uint64_t>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_DYNAMIC_FITNESS) &&
           VerifyField<float>(verifier, VT_VISION_RADIUS) &&
           VerifyField<float>(verifier, VT_SLEEP_RESTORE_FACTOR) &&
           VerifyField<uint8_t>(verifier, VT_ASLEEP) &&
           verifier.EndTable();
  }
};

struct OrganismBuilder {
  typedef Organism Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(flatbuffers::Offset<flatbuffers::String> kind) {
    fbb_.AddOffset(Organism::VT_KIND, kind);
  }
  void add_kingdom(Ecosystem::KingdomE kingdom) {
    fbb_.AddElement<uint8_t>(Organism::VT_KINGDOM, static_cast<uint8_t>(kingdom), 0);
  }
  void add_chromosome_number(uint16_t chromosome_number) {
    fbb_.AddElement<uint16_t>(Organism::VT_CHROMOSOME_NUMBER, chromosome_number, 0);
  }
  void add_monitor(Ecosystem::Monitor monitor) {
    fbb_.AddElement<uint8_t>(Organism::VT_MONITOR, static_cast<uint8_t>(monitor), 0);
  }
  void add_chromosome_structure(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>>> chromosome_structure) {
    fbb_.AddOffset(Organism::VT_CHROMOSOME_STRUCTURE, chromosome_structure);
  }
  void add_food_chain_rank(uint8_t food_chain_rank) {
    fbb_.AddElement<uint8_t>(Organism::VT_FOOD_CHAIN_RANK, food_chain_rank, 0);
  }
  void add_is_asexual(Ecosystem::Reproduction is_asexual) {
    fbb_.AddElement<uint8_t>(Organism::VT_IS_ASEXUAL, static_cast<uint8_t>(is_asexual), 0);
  }
  void add_age_fitness_on_death_ratio(float age_fitness_on_death_ratio) {
    fbb_.AddElement<float>(Organism::VT_AGE_FITNESS_ON_DEATH_RATIO, age_fitness_on_death_ratio, 0.0f);
  }
  void add_conceiving_probability(float conceiving_probability) {
    fbb_.AddElement<float>(Organism::VT_CONCEIVING_PROBABILITY, conceiving_probability, 0.0f);
  }
  void add_mating_probability(float mating_probability) {
    fbb_.AddElement<float>(Organism::VT_MATING_PROBABILITY, mating_probability, 0.0f);
  }
  void add_mating_age_start(uint32_t mating_age_start) {
    fbb_.AddElement<uint32_t>(Organism::VT_MATING_AGE_START, mating_age_start, 0);
  }
  void add_mating_age_end(uint32_t mating_age_end) {
    fbb_.AddElement<uint32_t>(Organism::VT_MATING_AGE_END, mating_age_end, 0);
  }
  void add_max_age(uint32_t max_age) {
    fbb_.AddElement<uint32_t>(Organism::VT_MAX_AGE, max_age, 0);
  }
  void add_mutation_probability(float mutation_probability) {
    fbb_.AddElement<float>(Organism::VT_MUTATION_PROBABILITY, mutation_probability, 0.0f);
  }
  void add_offsprings_factor(float offsprings_factor) {
    fbb_.AddElement<float>(Organism::VT_OFFSPRINGS_FACTOR, offsprings_factor, 0.0f);
  }
  void add_height_on_speed(float height_on_speed) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_ON_SPEED, height_on_speed, 0.0f);
  }
  void add_height_on_stamina(float height_on_stamina) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_ON_STAMINA, height_on_stamina, 0.0f);
  }
  void add_height_on_vitality(float height_on_vitality) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_ON_VITALITY, height_on_vitality, 0.0f);
  }
  void add_weight_on_speed(float weight_on_speed) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_ON_SPEED, weight_on_speed, 0.0f);
  }
  void add_weight_on_stamina(float weight_on_stamina) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_ON_STAMINA, weight_on_stamina, 0.0f);
  }
  void add_weight_on_vitality(float weight_on_vitality) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_ON_VITALITY, weight_on_vitality, 0.0f);
  }
  void add_vitality_on_appetite(float vitality_on_appetite) {
    fbb_.AddElement<float>(Organism::VT_VITALITY_ON_APPETITE, vitality_on_appetite, 0.0f);
  }
  void add_vitality_on_speed(float vitality_on_speed) {
    fbb_.AddElement<float>(Organism::VT_VITALITY_ON_SPEED, vitality_on_speed, 0.0f);
  }
  void add_stamina_on_appetite(float stamina_on_appetite) {
    fbb_.AddElement<float>(Organism::VT_STAMINA_ON_APPETITE, stamina_on_appetite, 0.0f);
  }
  void add_stamina_on_speed(float stamina_on_speed) {
    fbb_.AddElement<float>(Organism::VT_STAMINA_ON_SPEED, stamina_on_speed, 0.0f);
  }
  void add_theoretical_maximum_base_appetite(float theoretical_maximum_base_appetite) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_APPETITE, theoretical_maximum_base_appetite, 0.0f);
  }
  void add_theoretical_maximum_base_height(float theoretical_maximum_base_height) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_HEIGHT, theoretical_maximum_base_height, 0.0f);
  }
  void add_theoretical_maximum_base_speed(float theoretical_maximum_base_speed) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_SPEED, theoretical_maximum_base_speed, 0.0f);
  }
  void add_theoretical_maximum_base_stamina(float theoretical_maximum_base_stamina) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_STAMINA, theoretical_maximum_base_stamina, 0.0f);
  }
  void add_theoretical_maximum_base_vitality(float theoretical_maximum_base_vitality) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_VITALITY, theoretical_maximum_base_vitality, 0.0f);
  }
  void add_theoretical_maximum_base_weight(float theoretical_maximum_base_weight) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_WEIGHT, theoretical_maximum_base_weight, 0.0f);
  }
  void add_theoretical_maximum_height(float theoretical_maximum_height) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_HEIGHT, theoretical_maximum_height, 0.0f);
  }
  void add_theoretical_maximum_speed(float theoretical_maximum_speed) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_SPEED, theoretical_maximum_speed, 0.0f);
  }
  void add_theoretical_maximum_weight(float theoretical_maximum_weight) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_WEIGHT, theoretical_maximum_weight, 0.0f);
  }
  void add_theoretical_maximum_height_multiplier(float theoretical_maximum_height_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER, theoretical_maximum_height_multiplier, 0.0f);
  }
  void add_theoretical_maximum_speed_multiplier(float theoretical_maximum_speed_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER, theoretical_maximum_speed_multiplier, 0.0f);
  }
  void add_theoretical_maximum_stamina_multiplier(float theoretical_maximum_stamina_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER, theoretical_maximum_stamina_multiplier, 0.0f);
  }
  void add_theoretical_maximum_vitality_multiplier(float theoretical_maximum_vitality_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER, theoretical_maximum_vitality_multiplier, 0.0f);
  }
  void add_theoretical_maximum_weight_multiplier(float theoretical_maximum_weight_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER, theoretical_maximum_weight_multiplier, 0.0f);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Organism::VT_NAME, name);
  }
  void add_chromosome(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chromosome) {
    fbb_.AddOffset(Organism::VT_CHROMOSOME, chromosome);
  }
  void add_gender(Ecosystem::Gender gender) {
    fbb_.AddElement<uint8_t>(Organism::VT_GENDER, static_cast<uint8_t>(gender), 0);
  }
  void add_generation(uint32_t generation) {
    fbb_.AddElement<uint32_t>(Organism::VT_GENERATION, generation, 0);
  }
  void add_immunity(float immunity) {
    fbb_.AddElement<float>(Organism::VT_IMMUNITY, immunity, 0.0f);
  }
  void add_base_appetite(float base_appetite) {
    fbb_.AddElement<float>(Organism::VT_BASE_APPETITE, base_appetite, 0.0f);
  }
  void add_base_height(float base_height) {
    fbb_.AddElement<float>(Organism::VT_BASE_HEIGHT, base_height, 0.0f);
  }
  void add_base_speed(float base_speed) {
    fbb_.AddElement<float>(Organism::VT_BASE_SPEED, base_speed, 0.0f);
  }
  void add_base_stamina(float base_stamina) {
    fbb_.AddElement<float>(Organism::VT_BASE_STAMINA, base_stamina, 0.0f);
  }
  void add_base_vitality(float base_vitality) {
    fbb_.AddElement<float>(Organism::VT_BASE_VITALITY, base_vitality, 0.0f);
  }
  void add_base_weight(float base_weight) {
    fbb_.AddElement<float>(Organism::VT_BASE_WEIGHT, base_weight, 0.0f);
  }
  void add_height_multiplier(float height_multiplier) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_MULTIPLIER, height_multiplier, 0.0f);
  }
  void add_speed_multiplier(float speed_multiplier) {
    fbb_.AddElement<float>(Organism::VT_SPEED_MULTIPLIER, speed_multiplier, 0.0f);
  }
  void add_stamina_multiplier(float stamina_multiplier) {
    fbb_.AddElement<float>(Organism::VT_STAMINA_MULTIPLIER, stamina_multiplier, 0.0f);
  }
  void add_vitality_multiplier(float vitality_multiplier) {
    fbb_.AddElement<float>(Organism::VT_VITALITY_MULTIPLIER, vitality_multiplier, 0.0f);
  }
  void add_weight_multiplier(float weight_multiplier) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_MULTIPLIER, weight_multiplier, 0.0f);
  }
  void add_max_height(float max_height) {
    fbb_.AddElement<float>(Organism::VT_MAX_HEIGHT, max_height, 0.0f);
  }
  void add_max_weight(float max_weight) {
    fbb_.AddElement<float>(Organism::VT_MAX_WEIGHT, max_weight, 0.0f);
  }
  void add_age(uint32_t age) {
    fbb_.AddElement<uint32_t>(Organism::VT_AGE, age, 0);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT, height, 0.0f);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT, weight, 0.0f);
  }
  void add_age_death_factor(float age_death_factor) {
    fbb_.AddElement<float>(Organism::VT_AGE_DEATH_FACTOR, age_death_factor, 0.0f);
  }
  void add_fitness_death_factor(float fitness_death_factor) {
    fbb_.AddElement<float>(Organism::VT_FITNESS_DEATH_FACTOR, fitness_death_factor, 0.0f);
  }
  void add_death_factor(float death_factor) {
    fbb_.AddElement<float>(Organism::VT_DEATH_FACTOR, death_factor, 0.0f);
  }
  void add_static_fitness(float static_fitness) {
    fbb_.AddElement<float>(Organism::VT_STATIC_FITNESS, static_fitness, 0.0f);
  }
  void add_max_appetite_at_age(float max_appetite_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_APPETITE_AT_AGE, max_appetite_at_age, 0.0f);
  }
  void add_max_speed_at_age(float max_speed_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_SPEED_AT_AGE, max_speed_at_age, 0.0f);
  }
  void add_max_stamina_at_age(float max_stamina_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_STAMINA_AT_AGE, max_stamina_at_age, 0.0f);
  }
  void add_max_vitality_at_age(float max_vitality_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_VITALITY_AT_AGE, max_vitality_at_age, 0.0f);
  }
  void add_appetite(float appetite) {
    fbb_.AddElement<float>(Organism::VT_APPETITE, appetite, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Organism::VT_SPEED, speed, 0.0f);
  }
  void add_stamina(float stamina) {
    fbb_.AddElement<float>(Organism::VT_STAMINA, stamina, 0.0f);
  }
  void add_vitality(float vitality) {
    fbb_.AddElement<float>(Organism::VT_VITALITY, vitality, 0.0f);
  }
  void add_X(uint64_t X) {
    fbb_.AddElement<uint64_t>(Organism::VT_X, X, 0);
  }
  void add_Y(uint64_t Y) {
    fbb_.AddElement<uint64_t>(Organism::VT_Y, Y, 0);
  }
  void add_dynamic_fitness(float dynamic_fitness) {
    fbb_.AddElement<float>(Organism::VT_DYNAMIC_FITNESS, dynamic_fitness, 0.0f);
  }
  void add_vision_radius(float vision_radius) {
    fbb_.AddElement<float>(Organism::VT_VISION_RADIUS, vision_radius, 0.0f);
  }
  void add_sleep_restore_factor(float sleep_restore_factor) {
    fbb_.AddElement<float>(Organism::VT_SLEEP_RESTORE_FACTOR, sleep_restore_factor, 0.0f);
  }
  void add_asleep(Ecosystem::Sleep asleep) {
    fbb_.AddElement<uint8_t>(Organism::VT_ASLEEP, static_cast<uint8_t>(asleep), 0);
  }
  explicit OrganismBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Organism> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Organism>(end);
    fbb_.Required(o, Organism::VT_KIND);
    fbb_.Required(o, Organism::VT_NAME);
    fbb_.Required(o, Organism::VT_CHROMOSOME);
    return o;
  }
};

inline flatbuffers::Offset<Organism> CreateOrganism(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kind = 0,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::Animal,
    uint16_t chromosome_number = 0,
    Ecosystem::Monitor monitor = Ecosystem::Monitor::None,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>>> chromosome_structure = 0,
    uint8_t food_chain_rank = 0,
    Ecosystem::Reproduction is_asexual = Ecosystem::Reproduction::Sexual,
    float age_fitness_on_death_ratio = 0.0f,
    float conceiving_probability = 0.0f,
    float mating_probability = 0.0f,
    uint32_t mating_age_start = 0,
    uint32_t mating_age_end = 0,
    uint32_t max_age = 0,
    float mutation_probability = 0.0f,
    float offsprings_factor = 0.0f,
    float height_on_speed = 0.0f,
    float height_on_stamina = 0.0f,
    float height_on_vitality = 0.0f,
    float weight_on_speed = 0.0f,
    float weight_on_stamina = 0.0f,
    float weight_on_vitality = 0.0f,
    float vitality_on_appetite = 0.0f,
    float vitality_on_speed = 0.0f,
    float stamina_on_appetite = 0.0f,
    float stamina_on_speed = 0.0f,
    float theoretical_maximum_base_appetite = 0.0f,
    float theoretical_maximum_base_height = 0.0f,
    float theoretical_maximum_base_speed = 0.0f,
    float theoretical_maximum_base_stamina = 0.0f,
    float theoretical_maximum_base_vitality = 0.0f,
    float theoretical_maximum_base_weight = 0.0f,
    float theoretical_maximum_height = 0.0f,
    float theoretical_maximum_speed = 0.0f,
    float theoretical_maximum_weight = 0.0f,
    float theoretical_maximum_height_multiplier = 0.0f,
    float theoretical_maximum_speed_multiplier = 0.0f,
    float theoretical_maximum_stamina_multiplier = 0.0f,
    float theoretical_maximum_vitality_multiplier = 0.0f,
    float theoretical_maximum_weight_multiplier = 0.0f,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chromosome = 0,
    Ecosystem::Gender gender = Ecosystem::Gender::Male,
    uint32_t generation = 0,
    float immunity = 0.0f,
    float base_appetite = 0.0f,
    float base_height = 0.0f,
    float base_speed = 0.0f,
    float base_stamina = 0.0f,
    float base_vitality = 0.0f,
    float base_weight = 0.0f,
    float height_multiplier = 0.0f,
    float speed_multiplier = 0.0f,
    float stamina_multiplier = 0.0f,
    float vitality_multiplier = 0.0f,
    float weight_multiplier = 0.0f,
    float max_height = 0.0f,
    float max_weight = 0.0f,
    uint32_t age = 0,
    float height = 0.0f,
    float weight = 0.0f,
    float age_death_factor = 0.0f,
    float fitness_death_factor = 0.0f,
    float death_factor = 0.0f,
    float static_fitness = 0.0f,
    float max_appetite_at_age = 0.0f,
    float max_speed_at_age = 0.0f,
    float max_stamina_at_age = 0.0f,
    float max_vitality_at_age = 0.0f,
    float appetite = 0.0f,
    float speed = 0.0f,
    float stamina = 0.0f,
    float vitality = 0.0f,
    uint64_t X = 0,
    uint64_t Y = 0,
    float dynamic_fitness = 0.0f,
    float vision_radius = 0.0f,
    float sleep_restore_factor = 0.0f,
    Ecosystem::Sleep asleep = Ecosystem::Sleep::Awake) {
  OrganismBuilder builder_(_fbb);
  builder_.add_Y(Y);
  builder_.add_X(X);
  builder_.add_sleep_restore_factor(sleep_restore_factor);
  builder_.add_vision_radius(vision_radius);
  builder_.add_dynamic_fitness(dynamic_fitness);
  builder_.add_vitality(vitality);
  builder_.add_stamina(stamina);
  builder_.add_speed(speed);
  builder_.add_appetite(appetite);
  builder_.add_max_vitality_at_age(max_vitality_at_age);
  builder_.add_max_stamina_at_age(max_stamina_at_age);
  builder_.add_max_speed_at_age(max_speed_at_age);
  builder_.add_max_appetite_at_age(max_appetite_at_age);
  builder_.add_static_fitness(static_fitness);
  builder_.add_death_factor(death_factor);
  builder_.add_fitness_death_factor(fitness_death_factor);
  builder_.add_age_death_factor(age_death_factor);
  builder_.add_weight(weight);
  builder_.add_height(height);
  builder_.add_age(age);
  builder_.add_max_weight(max_weight);
  builder_.add_max_height(max_height);
  builder_.add_weight_multiplier(weight_multiplier);
  builder_.add_vitality_multiplier(vitality_multiplier);
  builder_.add_stamina_multiplier(stamina_multiplier);
  builder_.add_speed_multiplier(speed_multiplier);
  builder_.add_height_multiplier(height_multiplier);
  builder_.add_base_weight(base_weight);
  builder_.add_base_vitality(base_vitality);
  builder_.add_base_stamina(base_stamina);
  builder_.add_base_speed(base_speed);
  builder_.add_base_height(base_height);
  builder_.add_base_appetite(base_appetite);
  builder_.add_immunity(immunity);
  builder_.add_generation(generation);
  builder_.add_chromosome(chromosome);
  builder_.add_name(name);
  builder_.add_theoretical_maximum_weight_multiplier(theoretical_maximum_weight_multiplier);
  builder_.add_theoretical_maximum_vitality_multiplier(theoretical_maximum_vitality_multiplier);
  builder_.add_theoretical_maximum_stamina_multiplier(theoretical_maximum_stamina_multiplier);
  builder_.add_theoretical_maximum_speed_multiplier(theoretical_maximum_speed_multiplier);
  builder_.add_theoretical_maximum_height_multiplier(theoretical_maximum_height_multiplier);
  builder_.add_theoretical_maximum_weight(theoretical_maximum_weight);
  builder_.add_theoretical_maximum_speed(theoretical_maximum_speed);
  builder_.add_theoretical_maximum_height(theoretical_maximum_height);
  builder_.add_theoretical_maximum_base_weight(theoretical_maximum_base_weight);
  builder_.add_theoretical_maximum_base_vitality(theoretical_maximum_base_vitality);
  builder_.add_theoretical_maximum_base_stamina(theoretical_maximum_base_stamina);
  builder_.add_theoretical_maximum_base_speed(theoretical_maximum_base_speed);
  builder_.add_theoretical_maximum_base_height(theoretical_maximum_base_height);
  builder_.add_theoretical_maximum_base_appetite(theoretical_maximum_base_appetite);
  builder_.add_stamina_on_speed(stamina_on_speed);
  builder_.add_stamina_on_appetite(stamina_on_appetite);
  builder_.add_vitality_on_speed(vitality_on_speed);
  builder_.add_vitality_on_appetite(vitality_on_appetite);
  builder_.add_weight_on_vitality(weight_on_vitality);
  builder_.add_weight_on_stamina(weight_on_stamina);
  builder_.add_weight_on_speed(weight_on_speed);
  builder_.add_height_on_vitality(height_on_vitality);
  builder_.add_height_on_stamina(height_on_stamina);
  builder_.add_height_on_speed(height_on_speed);
  builder_.add_offsprings_factor(offsprings_factor);
  builder_.add_mutation_probability(mutation_probability);
  builder_.add_max_age(max_age);
  builder_.add_mating_age_end(mating_age_end);
  builder_.add_mating_age_start(mating_age_start);
  builder_.add_mating_probability(mating_probability);
  builder_.add_conceiving_probability(conceiving_probability);
  builder_.add_age_fitness_on_death_ratio(age_fitness_on_death_ratio);
  builder_.add_chromosome_structure(chromosome_structure);
  builder_.add_kind(kind);
  builder_.add_chromosome_number(chromosome_number);
  builder_.add_asleep(asleep);
  builder_.add_gender(gender);
  builder_.add_is_asexual(is_asexual);
  builder_.add_food_chain_rank(food_chain_rank);
  builder_.add_monitor(monitor);
  builder_.add_kingdom(kingdom);
  return builder_.Finish();
}

struct Organism::Traits {
  using type = Organism;
  static auto constexpr Create = CreateOrganism;
};

inline flatbuffers::Offset<Organism> CreateOrganismDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kind = nullptr,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::Animal,
    uint16_t chromosome_number = 0,
    Ecosystem::Monitor monitor = Ecosystem::Monitor::None,
    std::vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *chromosome_structure = nullptr,
    uint8_t food_chain_rank = 0,
    Ecosystem::Reproduction is_asexual = Ecosystem::Reproduction::Sexual,
    float age_fitness_on_death_ratio = 0.0f,
    float conceiving_probability = 0.0f,
    float mating_probability = 0.0f,
    uint32_t mating_age_start = 0,
    uint32_t mating_age_end = 0,
    uint32_t max_age = 0,
    float mutation_probability = 0.0f,
    float offsprings_factor = 0.0f,
    float height_on_speed = 0.0f,
    float height_on_stamina = 0.0f,
    float height_on_vitality = 0.0f,
    float weight_on_speed = 0.0f,
    float weight_on_stamina = 0.0f,
    float weight_on_vitality = 0.0f,
    float vitality_on_appetite = 0.0f,
    float vitality_on_speed = 0.0f,
    float stamina_on_appetite = 0.0f,
    float stamina_on_speed = 0.0f,
    float theoretical_maximum_base_appetite = 0.0f,
    float theoretical_maximum_base_height = 0.0f,
    float theoretical_maximum_base_speed = 0.0f,
    float theoretical_maximum_base_stamina = 0.0f,
    float theoretical_maximum_base_vitality = 0.0f,
    float theoretical_maximum_base_weight = 0.0f,
    float theoretical_maximum_height = 0.0f,
    float theoretical_maximum_speed = 0.0f,
    float theoretical_maximum_weight = 0.0f,
    float theoretical_maximum_height_multiplier = 0.0f,
    float theoretical_maximum_speed_multiplier = 0.0f,
    float theoretical_maximum_stamina_multiplier = 0.0f,
    float theoretical_maximum_vitality_multiplier = 0.0f,
    float theoretical_maximum_weight_multiplier = 0.0f,
    const char *name = nullptr,
    const std::vector<uint8_t> *chromosome = nullptr,
    Ecosystem::Gender gender = Ecosystem::Gender::Male,
    uint32_t generation = 0,
    float immunity = 0.0f,
    float base_appetite = 0.0f,
    float base_height = 0.0f,
    float base_speed = 0.0f,
    float base_stamina = 0.0f,
    float base_vitality = 0.0f,
    float base_weight = 0.0f,
    float height_multiplier = 0.0f,
    float speed_multiplier = 0.0f,
    float stamina_multiplier = 0.0f,
    float vitality_multiplier = 0.0f,
    float weight_multiplier = 0.0f,
    float max_height = 0.0f,
    float max_weight = 0.0f,
    uint32_t age = 0,
    float height = 0.0f,
    float weight = 0.0f,
    float age_death_factor = 0.0f,
    float fitness_death_factor = 0.0f,
    float death_factor = 0.0f,
    float static_fitness = 0.0f,
    float max_appetite_at_age = 0.0f,
    float max_speed_at_age = 0.0f,
    float max_stamina_at_age = 0.0f,
    float max_vitality_at_age = 0.0f,
    float appetite = 0.0f,
    float speed = 0.0f,
    float stamina = 0.0f,
    float vitality = 0.0f,
    uint64_t X = 0,
    uint64_t Y = 0,
    float dynamic_fitness = 0.0f,
    float vision_radius = 0.0f,
    float sleep_restore_factor = 0.0f,
    Ecosystem::Sleep asleep = Ecosystem::Sleep::Awake) {
  auto kind__ = kind ? _fbb.CreateString(kind) : 0;
  auto chromosome_structure__ = chromosome_structure ? _fbb.CreateVectorOfSortedTables<Ecosystem::ChromosomeStrand>(chromosome_structure) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto chromosome__ = chromosome ? _fbb.CreateVector<uint8_t>(*chromosome) : 0;
  return Ecosystem::CreateOrganism(
      _fbb,
      kind__,
      kingdom,
      chromosome_number,
      monitor,
      chromosome_structure__,
      food_chain_rank,
      is_asexual,
      age_fitness_on_death_ratio,
      conceiving_probability,
      mating_probability,
      mating_age_start,
      mating_age_end,
      max_age,
      mutation_probability,
      offsprings_factor,
      height_on_speed,
      height_on_stamina,
      height_on_vitality,
      weight_on_speed,
      weight_on_stamina,
      weight_on_vitality,
      vitality_on_appetite,
      vitality_on_speed,
      stamina_on_appetite,
      stamina_on_speed,
      theoretical_maximum_base_appetite,
      theoretical_maximum_base_height,
      theoretical_maximum_base_speed,
      theoretical_maximum_base_stamina,
      theoretical_maximum_base_vitality,
      theoretical_maximum_base_weight,
      theoretical_maximum_height,
      theoretical_maximum_speed,
      theoretical_maximum_weight,
      theoretical_maximum_height_multiplier,
      theoretical_maximum_speed_multiplier,
      theoretical_maximum_stamina_multiplier,
      theoretical_maximum_vitality_multiplier,
      theoretical_maximum_weight_multiplier,
      name__,
      chromosome__,
      gender,
      generation,
      immunity,
      base_appetite,
      base_height,
      base_speed,
      base_stamina,
      base_vitality,
      base_weight,
      height_multiplier,
      speed_multiplier,
      stamina_multiplier,
      vitality_multiplier,
      weight_multiplier,
      max_height,
      max_weight,
      age,
      height,
      weight,
      age_death_factor,
      fitness_death_factor,
      death_factor,
      static_fitness,
      max_appetite_at_age,
      max_speed_at_age,
      max_stamina_at_age,
      max_vitality_at_age,
      appetite,
      speed,
      stamina,
      vitality,
      X,
      Y,
      dynamic_fitness,
      vision_radius,
      sleep_restore_factor,
      asleep);
}

struct Species FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpeciesBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpeciesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4,
    VT_KINGDOM = 6,
    VT_ORGANISM = 8
  };
  const flatbuffers::String *kind() const {
    return GetPointer<const flatbuffers::String *>(VT_KIND);
  }
  flatbuffers::String *mutable_kind() {
    return GetPointer<flatbuffers::String *>(VT_KIND);
  }
  bool KeyCompareLessThan(const Species *o) const {
    return *kind() < *o->kind();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(kind()->c_str(), val);
  }
  Ecosystem::KingdomE kingdom() const {
    return static_cast<Ecosystem::KingdomE>(GetField<uint8_t>(VT_KINGDOM, 0));
  }
  bool mutate_kingdom(Ecosystem::KingdomE _kingdom = static_cast<Ecosystem::KingdomE>(0)) {
    return SetField<uint8_t>(VT_KINGDOM, static_cast<uint8_t>(_kingdom), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *organism() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *>(VT_ORGANISM);
  }
  flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *mutable_organism() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *>(VT_ORGANISM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KIND) &&
           verifier.VerifyString(kind()) &&
           VerifyField<uint8_t>(verifier, VT_KINGDOM) &&
           VerifyOffset(verifier, VT_ORGANISM) &&
           verifier.VerifyVector(organism()) &&
           verifier.VerifyVectorOfTables(organism()) &&
           verifier.EndTable();
  }
};

struct SpeciesBuilder {
  typedef Species Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(flatbuffers::Offset<flatbuffers::String> kind) {
    fbb_.AddOffset(Species::VT_KIND, kind);
  }
  void add_kingdom(Ecosystem::KingdomE kingdom) {
    fbb_.AddElement<uint8_t>(Species::VT_KINGDOM, static_cast<uint8_t>(kingdom), 0);
  }
  void add_organism(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>>> organism) {
    fbb_.AddOffset(Species::VT_ORGANISM, organism);
  }
  explicit SpeciesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Species> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Species>(end);
    fbb_.Required(o, Species::VT_KIND);
    return o;
  }
};

inline flatbuffers::Offset<Species> CreateSpecies(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kind = 0,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::Animal,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>>> organism = 0) {
  SpeciesBuilder builder_(_fbb);
  builder_.add_organism(organism);
  builder_.add_kind(kind);
  builder_.add_kingdom(kingdom);
  return builder_.Finish();
}

struct Species::Traits {
  using type = Species;
  static auto constexpr Create = CreateSpecies;
};

inline flatbuffers::Offset<Species> CreateSpeciesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kind = nullptr,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::Animal,
    std::vector<flatbuffers::Offset<Ecosystem::Organism>> *organism = nullptr) {
  auto kind__ = kind ? _fbb.CreateString(kind) : 0;
  auto organism__ = organism ? _fbb.CreateVectorOfSortedTables<Ecosystem::Organism>(organism) : 0;
  return Ecosystem::CreateSpecies(
      _fbb,
      kind__,
      kingdom,
      organism__);
}

struct World FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorldBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WorldTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_YEAR = 4,
    VT_SPECIES = 6
  };
  uint32_t year() const {
    return GetField<uint32_t>(VT_YEAR, 0);
  }
  bool mutate_year(uint32_t _year = 0) {
    return SetField<uint32_t>(VT_YEAR, _year, 0);
  }
  bool KeyCompareLessThan(const World *o) const {
    return year() < o->year();
  }
  int KeyCompareWithValue(uint32_t val) const {
    return static_cast<int>(year() > val) - static_cast<int>(year() < val);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *species() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *>(VT_SPECIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *mutable_species() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *>(VT_SPECIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_YEAR) &&
           VerifyOffset(verifier, VT_SPECIES) &&
           verifier.VerifyVector(species()) &&
           verifier.VerifyVectorOfTables(species()) &&
           verifier.EndTable();
  }
};

struct WorldBuilder {
  typedef World Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_year(uint32_t year) {
    fbb_.AddElement<uint32_t>(World::VT_YEAR, year, 0);
  }
  void add_species(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>>> species) {
    fbb_.AddOffset(World::VT_SPECIES, species);
  }
  explicit WorldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<World> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<World>(end);
    return o;
  }
};

inline flatbuffers::Offset<World> CreateWorld(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t year = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>>> species = 0) {
  WorldBuilder builder_(_fbb);
  builder_.add_species(species);
  builder_.add_year(year);
  return builder_.Finish();
}

struct World::Traits {
  using type = World;
  static auto constexpr Create = CreateWorld;
};

inline flatbuffers::Offset<World> CreateWorldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t year = 0,
    std::vector<flatbuffers::Offset<Ecosystem::Species>> *species = nullptr) {
  auto species__ = species ? _fbb.CreateVectorOfSortedTables<Ecosystem::Species>(species) : 0;
  return Ecosystem::CreateWorld(
      _fbb,
      year,
      species__);
}

inline const flatbuffers::TypeTable *GenderTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::GenderTypeTable
  };
  static const char * const names[] = {
    "Male",
    "Female"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReproductionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::ReproductionTypeTable
  };
  static const char * const names[] = {
    "Sexual",
    "Asexual"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MonitorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::MonitorTypeTable
  };
  static const char * const names[] = {
    "None",
    "Simulation"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SleepTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::SleepTypeTable
  };
  static const char * const names[] = {
    "Awake",
    "Drowsy",
    "Asleep"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KingdomETypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::KingdomETypeTable
  };
  static const char * const names[] = {
    "Animal",
    "Plant"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ChromosomeStrandTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "code",
    "start",
    "length"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OrganismTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 1, 2 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 3 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 0, 4 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 5 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::KingdomETypeTable,
    Ecosystem::MonitorTypeTable,
    Ecosystem::ChromosomeStrandTypeTable,
    Ecosystem::ReproductionTypeTable,
    Ecosystem::GenderTypeTable,
    Ecosystem::SleepTypeTable
  };
  static const char * const names[] = {
    "kind",
    "kingdom",
    "chromosome_number",
    "monitor",
    "chromosome_structure",
    "food_chain_rank",
    "is_asexual",
    "age_fitness_on_death_ratio",
    "conceiving_probability",
    "mating_probability",
    "mating_age_start",
    "mating_age_end",
    "max_age",
    "mutation_probability",
    "offsprings_factor",
    "height_on_speed",
    "height_on_stamina",
    "height_on_vitality",
    "weight_on_speed",
    "weight_on_stamina",
    "weight_on_vitality",
    "vitality_on_appetite",
    "vitality_on_speed",
    "stamina_on_appetite",
    "stamina_on_speed",
    "theoretical_maximum_base_appetite",
    "theoretical_maximum_base_height",
    "theoretical_maximum_base_speed",
    "theoretical_maximum_base_stamina",
    "theoretical_maximum_base_vitality",
    "theoretical_maximum_base_weight",
    "theoretical_maximum_height",
    "theoretical_maximum_speed",
    "theoretical_maximum_weight",
    "theoretical_maximum_height_multiplier",
    "theoretical_maximum_speed_multiplier",
    "theoretical_maximum_stamina_multiplier",
    "theoretical_maximum_vitality_multiplier",
    "theoretical_maximum_weight_multiplier",
    "name",
    "chromosome",
    "gender",
    "generation",
    "immunity",
    "base_appetite",
    "base_height",
    "base_speed",
    "base_stamina",
    "base_vitality",
    "base_weight",
    "height_multiplier",
    "speed_multiplier",
    "stamina_multiplier",
    "vitality_multiplier",
    "weight_multiplier",
    "max_height",
    "max_weight",
    "age",
    "height",
    "weight",
    "age_death_factor",
    "fitness_death_factor",
    "death_factor",
    "static_fitness",
    "max_appetite_at_age",
    "max_speed_at_age",
    "max_stamina_at_age",
    "max_vitality_at_age",
    "appetite",
    "speed",
    "stamina",
    "vitality",
    "X",
    "Y",
    "dynamic_fitness",
    "vision_radius",
    "sleep_restore_factor",
    "asleep"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 78, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpeciesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::KingdomETypeTable,
    Ecosystem::OrganismTypeTable
  };
  static const char * const names[] = {
    "kind",
    "kingdom",
    "organism"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WorldTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::SpeciesTypeTable
  };
  static const char * const names[] = {
    "year",
    "species"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const Ecosystem::World *GetWorld(const void *buf) {
  return flatbuffers::GetRoot<Ecosystem::World>(buf);
}

inline const Ecosystem::World *GetSizePrefixedWorld(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Ecosystem::World>(buf);
}

inline World *GetMutableWorld(void *buf) {
  return flatbuffers::GetMutableRoot<World>(buf);
}

inline Ecosystem::World *GetMutableSizePrefixedWorld(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<Ecosystem::World>(buf);
}

inline bool VerifyWorldBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Ecosystem::World>(nullptr);
}

inline bool VerifySizePrefixedWorldBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Ecosystem::World>(nullptr);
}

inline void FinishWorldBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Ecosystem::World> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWorldBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Ecosystem::World> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Ecosystem

#endif  // FLATBUFFERS_GENERATED_WORLD_ECOSYSTEM_H_
