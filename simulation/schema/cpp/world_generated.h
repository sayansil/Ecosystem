// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORLD_ECOSYSTEM_H_
#define FLATBUFFERS_GENERATED_WORLD_ECOSYSTEM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 29,
             "Non-compatible flatbuffers version included");

namespace Ecosystem {

struct ChromosomeStrand;
struct ChromosomeStrandBuilder;
struct ChromosomeStrandT;

struct Organism;
struct OrganismBuilder;
struct OrganismT;

struct Species;
struct SpeciesBuilder;
struct SpeciesT;

struct World;
struct WorldBuilder;
struct WorldT;

inline const flatbuffers::TypeTable *ChromosomeStrandTypeTable();

inline const flatbuffers::TypeTable *OrganismTypeTable();

inline const flatbuffers::TypeTable *SpeciesTypeTable();

inline const flatbuffers::TypeTable *WorldTypeTable();

enum class Gender : uint8_t {
  male = 0,
  female = 1,
  MIN = male,
  MAX = female
};

inline const Gender (&EnumValuesGender())[2] {
  static const Gender values[] = {
    Gender::male,
    Gender::female
  };
  return values;
}

inline const char * const *EnumNamesGender() {
  static const char * const names[3] = {
    "male",
    "female",
    nullptr
  };
  return names;
}

inline const char *EnumNameGender(Gender e) {
  if (flatbuffers::IsOutRange(e, Gender::male, Gender::female)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGender()[index];
}

enum class Reproduction : uint8_t {
  sexual = 0,
  asexual = 1,
  MIN = sexual,
  MAX = asexual
};

inline const Reproduction (&EnumValuesReproduction())[2] {
  static const Reproduction values[] = {
    Reproduction::sexual,
    Reproduction::asexual
  };
  return values;
}

inline const char * const *EnumNamesReproduction() {
  static const char * const names[3] = {
    "sexual",
    "asexual",
    nullptr
  };
  return names;
}

inline const char *EnumNameReproduction(Reproduction e) {
  if (flatbuffers::IsOutRange(e, Reproduction::sexual, Reproduction::asexual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReproduction()[index];
}

enum class Monitor : uint8_t {
  none = 0,
  simulation = 1,
  MIN = none,
  MAX = simulation
};

inline const Monitor (&EnumValuesMonitor())[2] {
  static const Monitor values[] = {
    Monitor::none,
    Monitor::simulation
  };
  return values;
}

inline const char * const *EnumNamesMonitor() {
  static const char * const names[3] = {
    "none",
    "simulation",
    nullptr
  };
  return names;
}

inline const char *EnumNameMonitor(Monitor e) {
  if (flatbuffers::IsOutRange(e, Monitor::none, Monitor::simulation)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMonitor()[index];
}

enum class Sleep : uint8_t {
  awake = 0,
  drowsy = 1,
  asleep = 2,
  MIN = awake,
  MAX = asleep
};

inline const Sleep (&EnumValuesSleep())[3] {
  static const Sleep values[] = {
    Sleep::awake,
    Sleep::drowsy,
    Sleep::asleep
  };
  return values;
}

inline const char * const *EnumNamesSleep() {
  static const char * const names[4] = {
    "awake",
    "drowsy",
    "asleep",
    nullptr
  };
  return names;
}

inline const char *EnumNameSleep(Sleep e) {
  if (flatbuffers::IsOutRange(e, Sleep::awake, Sleep::asleep)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSleep()[index];
}

enum class KingdomE : uint8_t {
  animal = 0,
  plant = 1,
  MIN = animal,
  MAX = plant
};

inline const KingdomE (&EnumValuesKingdomE())[2] {
  static const KingdomE values[] = {
    KingdomE::animal,
    KingdomE::plant
  };
  return values;
}

inline const char * const *EnumNamesKingdomE() {
  static const char * const names[3] = {
    "animal",
    "plant",
    nullptr
  };
  return names;
}

inline const char *EnumNameKingdomE(KingdomE e) {
  if (flatbuffers::IsOutRange(e, KingdomE::animal, KingdomE::plant)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKingdomE()[index];
}

struct ChromosomeStrandT : public flatbuffers::NativeTable {
  typedef ChromosomeStrand TableType;
  std::string code{};
  uint16_t start = 0;
  uint16_t length = 0;
};

struct ChromosomeStrand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChromosomeStrandT NativeTableType;
  typedef ChromosomeStrandBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ChromosomeStrandTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_START = 6,
    VT_LENGTH = 8
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  flatbuffers::String *mutable_code() {
    return GetPointer<flatbuffers::String *>(VT_CODE);
  }
  bool KeyCompareLessThan(const ChromosomeStrand *o) const {
    return *code() < *o->code();
  }
  int KeyCompareWithValue(const char *_code) const {
    return strcmp(code()->c_str(), _code);
  }
  uint16_t start() const {
    return GetField<uint16_t>(VT_START, 0);
  }
  bool mutate_start(uint16_t _start = 0) {
    return SetField<uint16_t>(VT_START, _start, 0);
  }
  uint16_t length() const {
    return GetField<uint16_t>(VT_LENGTH, 0);
  }
  bool mutate_length(uint16_t _length = 0) {
    return SetField<uint16_t>(VT_LENGTH, _length, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyField<uint16_t>(verifier, VT_START, 2) &&
           VerifyField<uint16_t>(verifier, VT_LENGTH, 2) &&
           verifier.EndTable();
  }
  ChromosomeStrandT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChromosomeStrandT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ChromosomeStrand> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChromosomeStrandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChromosomeStrandBuilder {
  typedef ChromosomeStrand Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(ChromosomeStrand::VT_CODE, code);
  }
  void add_start(uint16_t start) {
    fbb_.AddElement<uint16_t>(ChromosomeStrand::VT_START, start, 0);
  }
  void add_length(uint16_t length) {
    fbb_.AddElement<uint16_t>(ChromosomeStrand::VT_LENGTH, length, 0);
  }
  explicit ChromosomeStrandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChromosomeStrand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChromosomeStrand>(end);
    fbb_.Required(o, ChromosomeStrand::VT_CODE);
    return o;
  }
};

inline flatbuffers::Offset<ChromosomeStrand> CreateChromosomeStrand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    uint16_t start = 0,
    uint16_t length = 0) {
  ChromosomeStrandBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_length(length);
  builder_.add_start(start);
  return builder_.Finish();
}

struct ChromosomeStrand::Traits {
  using type = ChromosomeStrand;
  static auto constexpr Create = CreateChromosomeStrand;
};

inline flatbuffers::Offset<ChromosomeStrand> CreateChromosomeStrandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    uint16_t start = 0,
    uint16_t length = 0) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  return Ecosystem::CreateChromosomeStrand(
      _fbb,
      code__,
      start,
      length);
}

flatbuffers::Offset<ChromosomeStrand> CreateChromosomeStrand(flatbuffers::FlatBufferBuilder &_fbb, const ChromosomeStrandT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OrganismT : public flatbuffers::NativeTable {
  typedef Organism TableType;
  std::string kind{};
  Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::animal;
  uint16_t chromosome_number = 0;
  std::vector<std::unique_ptr<Ecosystem::ChromosomeStrandT>> chromosome_structure{};
  uint8_t food_chain_rank = 0;
  Ecosystem::Reproduction sexuality = Ecosystem::Reproduction::sexual;
  float age_fitness_on_death_ratio = 0.0f;
  float conceiving_probability = 0.0f;
  float mating_probability = 0.0f;
  uint32_t mating_age_start = 0;
  uint32_t mating_age_end = 0;
  uint32_t max_age = 0;
  float mutation_probability = 0.0f;
  float offsprings_factor = 0.0f;
  float height_on_speed = 0.0f;
  float height_on_stamina = 0.0f;
  float height_on_vitality = 0.0f;
  float weight_on_speed = 0.0f;
  float weight_on_stamina = 0.0f;
  float weight_on_vitality = 0.0f;
  float vitality_on_appetite = 0.0f;
  float vitality_on_speed = 0.0f;
  float stamina_on_appetite = 0.0f;
  float stamina_on_speed = 0.0f;
  float theoretical_maximum_base_appetite = 0.0f;
  float theoretical_maximum_base_height = 0.0f;
  float theoretical_maximum_base_speed = 0.0f;
  float theoretical_maximum_base_stamina = 0.0f;
  float theoretical_maximum_base_vitality = 0.0f;
  float theoretical_maximum_base_weight = 0.0f;
  float theoretical_maximum_height = 0.0f;
  float theoretical_maximum_speed = 0.0f;
  float theoretical_maximum_weight = 0.0f;
  float theoretical_maximum_height_multiplier = 0.0f;
  float theoretical_maximum_speed_multiplier = 0.0f;
  float theoretical_maximum_stamina_multiplier = 0.0f;
  float theoretical_maximum_vitality_multiplier = 0.0f;
  float theoretical_maximum_weight_multiplier = 0.0f;
  std::string name{};
  std::vector<uint8_t> chromosome{};
  Ecosystem::Gender gender = Ecosystem::Gender::male;
  uint32_t generation = 0;
  float immunity = 0.0f;
  float base_appetite = 0.0f;
  float base_height = 0.0f;
  float base_speed = 0.0f;
  float base_stamina = 0.0f;
  float base_vitality = 0.0f;
  float base_weight = 0.0f;
  float height_multiplier = 0.0f;
  float speed_multiplier = 0.0f;
  float stamina_multiplier = 0.0f;
  float vitality_multiplier = 0.0f;
  float weight_multiplier = 0.0f;
  float max_height = 0.0f;
  float max_weight = 0.0f;
  uint32_t age = 0;
  float height = 0.0f;
  float weight = 0.0f;
  float static_fitness = 0.0f;
  float max_appetite_at_age = 0.0f;
  float max_speed_at_age = 0.0f;
  float max_stamina_at_age = 0.0f;
  float max_vitality_at_age = 0.0f;
  float appetite = 0.0f;
  float speed = 0.0f;
  float stamina = 0.0f;
  float vitality = 0.0f;
  uint64_t X = 0;
  uint64_t Y = 0;
  float dynamic_fitness = 1.0f;
  float vision_radius = 0.0f;
  float sleep_restore_factor = 0.0f;
  Ecosystem::Sleep asleep = Ecosystem::Sleep::awake;
  Ecosystem::Monitor monitor = Ecosystem::Monitor::none;
  OrganismT() = default;
  OrganismT(const OrganismT &o);
  OrganismT(OrganismT&&) FLATBUFFERS_NOEXCEPT = default;
  OrganismT &operator=(OrganismT o) FLATBUFFERS_NOEXCEPT;
};

struct Organism FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrganismT NativeTableType;
  typedef OrganismBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OrganismTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4,
    VT_KINGDOM = 6,
    VT_CHROMOSOME_NUMBER = 8,
    VT_CHROMOSOME_STRUCTURE = 10,
    VT_FOOD_CHAIN_RANK = 12,
    VT_SEXUALITY = 14,
    VT_AGE_FITNESS_ON_DEATH_RATIO = 16,
    VT_CONCEIVING_PROBABILITY = 18,
    VT_MATING_PROBABILITY = 20,
    VT_MATING_AGE_START = 22,
    VT_MATING_AGE_END = 24,
    VT_MAX_AGE = 26,
    VT_MUTATION_PROBABILITY = 28,
    VT_OFFSPRINGS_FACTOR = 30,
    VT_HEIGHT_ON_SPEED = 32,
    VT_HEIGHT_ON_STAMINA = 34,
    VT_HEIGHT_ON_VITALITY = 36,
    VT_WEIGHT_ON_SPEED = 38,
    VT_WEIGHT_ON_STAMINA = 40,
    VT_WEIGHT_ON_VITALITY = 42,
    VT_VITALITY_ON_APPETITE = 44,
    VT_VITALITY_ON_SPEED = 46,
    VT_STAMINA_ON_APPETITE = 48,
    VT_STAMINA_ON_SPEED = 50,
    VT_THEORETICAL_MAXIMUM_BASE_APPETITE = 52,
    VT_THEORETICAL_MAXIMUM_BASE_HEIGHT = 54,
    VT_THEORETICAL_MAXIMUM_BASE_SPEED = 56,
    VT_THEORETICAL_MAXIMUM_BASE_STAMINA = 58,
    VT_THEORETICAL_MAXIMUM_BASE_VITALITY = 60,
    VT_THEORETICAL_MAXIMUM_BASE_WEIGHT = 62,
    VT_THEORETICAL_MAXIMUM_HEIGHT = 64,
    VT_THEORETICAL_MAXIMUM_SPEED = 66,
    VT_THEORETICAL_MAXIMUM_WEIGHT = 68,
    VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER = 70,
    VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER = 72,
    VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER = 74,
    VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER = 76,
    VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER = 78,
    VT_NAME = 80,
    VT_CHROMOSOME = 82,
    VT_GENDER = 84,
    VT_GENERATION = 86,
    VT_IMMUNITY = 88,
    VT_BASE_APPETITE = 90,
    VT_BASE_HEIGHT = 92,
    VT_BASE_SPEED = 94,
    VT_BASE_STAMINA = 96,
    VT_BASE_VITALITY = 98,
    VT_BASE_WEIGHT = 100,
    VT_HEIGHT_MULTIPLIER = 102,
    VT_SPEED_MULTIPLIER = 104,
    VT_STAMINA_MULTIPLIER = 106,
    VT_VITALITY_MULTIPLIER = 108,
    VT_WEIGHT_MULTIPLIER = 110,
    VT_MAX_HEIGHT = 112,
    VT_MAX_WEIGHT = 114,
    VT_AGE = 116,
    VT_HEIGHT = 118,
    VT_WEIGHT = 120,
    VT_STATIC_FITNESS = 122,
    VT_MAX_APPETITE_AT_AGE = 124,
    VT_MAX_SPEED_AT_AGE = 126,
    VT_MAX_STAMINA_AT_AGE = 128,
    VT_MAX_VITALITY_AT_AGE = 130,
    VT_APPETITE = 132,
    VT_SPEED = 134,
    VT_STAMINA = 136,
    VT_VITALITY = 138,
    VT_X = 140,
    VT_Y = 142,
    VT_DYNAMIC_FITNESS = 144,
    VT_VISION_RADIUS = 146,
    VT_SLEEP_RESTORE_FACTOR = 148,
    VT_ASLEEP = 150,
    VT_MONITOR = 152
  };
  /// Fixed for a species
  const flatbuffers::String *kind() const {
    return GetPointer<const flatbuffers::String *>(VT_KIND);
  }
  flatbuffers::String *mutable_kind() {
    return GetPointer<flatbuffers::String *>(VT_KIND);
  }
  Ecosystem::KingdomE kingdom() const {
    return static_cast<Ecosystem::KingdomE>(GetField<uint8_t>(VT_KINGDOM, 0));
  }
  bool mutate_kingdom(Ecosystem::KingdomE _kingdom = static_cast<Ecosystem::KingdomE>(0)) {
    return SetField<uint8_t>(VT_KINGDOM, static_cast<uint8_t>(_kingdom), 0);
  }
  uint16_t chromosome_number() const {
    return GetField<uint16_t>(VT_CHROMOSOME_NUMBER, 0);
  }
  bool mutate_chromosome_number(uint16_t _chromosome_number = 0) {
    return SetField<uint16_t>(VT_CHROMOSOME_NUMBER, _chromosome_number, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *chromosome_structure() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *>(VT_CHROMOSOME_STRUCTURE);
  }
  flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *mutable_chromosome_structure() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *>(VT_CHROMOSOME_STRUCTURE);
  }
  uint8_t food_chain_rank() const {
    return GetField<uint8_t>(VT_FOOD_CHAIN_RANK, 0);
  }
  bool mutate_food_chain_rank(uint8_t _food_chain_rank = 0) {
    return SetField<uint8_t>(VT_FOOD_CHAIN_RANK, _food_chain_rank, 0);
  }
  Ecosystem::Reproduction sexuality() const {
    return static_cast<Ecosystem::Reproduction>(GetField<uint8_t>(VT_SEXUALITY, 0));
  }
  bool mutate_sexuality(Ecosystem::Reproduction _sexuality = static_cast<Ecosystem::Reproduction>(0)) {
    return SetField<uint8_t>(VT_SEXUALITY, static_cast<uint8_t>(_sexuality), 0);
  }
  float age_fitness_on_death_ratio() const {
    return GetField<float>(VT_AGE_FITNESS_ON_DEATH_RATIO, 0.0f);
  }
  bool mutate_age_fitness_on_death_ratio(float _age_fitness_on_death_ratio = 0.0f) {
    return SetField<float>(VT_AGE_FITNESS_ON_DEATH_RATIO, _age_fitness_on_death_ratio, 0.0f);
  }
  float conceiving_probability() const {
    return GetField<float>(VT_CONCEIVING_PROBABILITY, 0.0f);
  }
  bool mutate_conceiving_probability(float _conceiving_probability = 0.0f) {
    return SetField<float>(VT_CONCEIVING_PROBABILITY, _conceiving_probability, 0.0f);
  }
  float mating_probability() const {
    return GetField<float>(VT_MATING_PROBABILITY, 0.0f);
  }
  bool mutate_mating_probability(float _mating_probability = 0.0f) {
    return SetField<float>(VT_MATING_PROBABILITY, _mating_probability, 0.0f);
  }
  uint32_t mating_age_start() const {
    return GetField<uint32_t>(VT_MATING_AGE_START, 0);
  }
  bool mutate_mating_age_start(uint32_t _mating_age_start = 0) {
    return SetField<uint32_t>(VT_MATING_AGE_START, _mating_age_start, 0);
  }
  uint32_t mating_age_end() const {
    return GetField<uint32_t>(VT_MATING_AGE_END, 0);
  }
  bool mutate_mating_age_end(uint32_t _mating_age_end = 0) {
    return SetField<uint32_t>(VT_MATING_AGE_END, _mating_age_end, 0);
  }
  uint32_t max_age() const {
    return GetField<uint32_t>(VT_MAX_AGE, 0);
  }
  bool mutate_max_age(uint32_t _max_age = 0) {
    return SetField<uint32_t>(VT_MAX_AGE, _max_age, 0);
  }
  float mutation_probability() const {
    return GetField<float>(VT_MUTATION_PROBABILITY, 0.0f);
  }
  bool mutate_mutation_probability(float _mutation_probability = 0.0f) {
    return SetField<float>(VT_MUTATION_PROBABILITY, _mutation_probability, 0.0f);
  }
  float offsprings_factor() const {
    return GetField<float>(VT_OFFSPRINGS_FACTOR, 0.0f);
  }
  bool mutate_offsprings_factor(float _offsprings_factor = 0.0f) {
    return SetField<float>(VT_OFFSPRINGS_FACTOR, _offsprings_factor, 0.0f);
  }
  float height_on_speed() const {
    return GetField<float>(VT_HEIGHT_ON_SPEED, 0.0f);
  }
  bool mutate_height_on_speed(float _height_on_speed = 0.0f) {
    return SetField<float>(VT_HEIGHT_ON_SPEED, _height_on_speed, 0.0f);
  }
  float height_on_stamina() const {
    return GetField<float>(VT_HEIGHT_ON_STAMINA, 0.0f);
  }
  bool mutate_height_on_stamina(float _height_on_stamina = 0.0f) {
    return SetField<float>(VT_HEIGHT_ON_STAMINA, _height_on_stamina, 0.0f);
  }
  float height_on_vitality() const {
    return GetField<float>(VT_HEIGHT_ON_VITALITY, 0.0f);
  }
  bool mutate_height_on_vitality(float _height_on_vitality = 0.0f) {
    return SetField<float>(VT_HEIGHT_ON_VITALITY, _height_on_vitality, 0.0f);
  }
  float weight_on_speed() const {
    return GetField<float>(VT_WEIGHT_ON_SPEED, 0.0f);
  }
  bool mutate_weight_on_speed(float _weight_on_speed = 0.0f) {
    return SetField<float>(VT_WEIGHT_ON_SPEED, _weight_on_speed, 0.0f);
  }
  float weight_on_stamina() const {
    return GetField<float>(VT_WEIGHT_ON_STAMINA, 0.0f);
  }
  bool mutate_weight_on_stamina(float _weight_on_stamina = 0.0f) {
    return SetField<float>(VT_WEIGHT_ON_STAMINA, _weight_on_stamina, 0.0f);
  }
  float weight_on_vitality() const {
    return GetField<float>(VT_WEIGHT_ON_VITALITY, 0.0f);
  }
  bool mutate_weight_on_vitality(float _weight_on_vitality = 0.0f) {
    return SetField<float>(VT_WEIGHT_ON_VITALITY, _weight_on_vitality, 0.0f);
  }
  float vitality_on_appetite() const {
    return GetField<float>(VT_VITALITY_ON_APPETITE, 0.0f);
  }
  bool mutate_vitality_on_appetite(float _vitality_on_appetite = 0.0f) {
    return SetField<float>(VT_VITALITY_ON_APPETITE, _vitality_on_appetite, 0.0f);
  }
  float vitality_on_speed() const {
    return GetField<float>(VT_VITALITY_ON_SPEED, 0.0f);
  }
  bool mutate_vitality_on_speed(float _vitality_on_speed = 0.0f) {
    return SetField<float>(VT_VITALITY_ON_SPEED, _vitality_on_speed, 0.0f);
  }
  float stamina_on_appetite() const {
    return GetField<float>(VT_STAMINA_ON_APPETITE, 0.0f);
  }
  bool mutate_stamina_on_appetite(float _stamina_on_appetite = 0.0f) {
    return SetField<float>(VT_STAMINA_ON_APPETITE, _stamina_on_appetite, 0.0f);
  }
  float stamina_on_speed() const {
    return GetField<float>(VT_STAMINA_ON_SPEED, 0.0f);
  }
  bool mutate_stamina_on_speed(float _stamina_on_speed = 0.0f) {
    return SetField<float>(VT_STAMINA_ON_SPEED, _stamina_on_speed, 0.0f);
  }
  float theoretical_maximum_base_appetite() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_APPETITE, 0.0f);
  }
  bool mutate_theoretical_maximum_base_appetite(float _theoretical_maximum_base_appetite = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_APPETITE, _theoretical_maximum_base_appetite, 0.0f);
  }
  float theoretical_maximum_base_height() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_HEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_base_height(float _theoretical_maximum_base_height = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_HEIGHT, _theoretical_maximum_base_height, 0.0f);
  }
  float theoretical_maximum_base_speed() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_SPEED, 0.0f);
  }
  bool mutate_theoretical_maximum_base_speed(float _theoretical_maximum_base_speed = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_SPEED, _theoretical_maximum_base_speed, 0.0f);
  }
  float theoretical_maximum_base_stamina() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_STAMINA, 0.0f);
  }
  bool mutate_theoretical_maximum_base_stamina(float _theoretical_maximum_base_stamina = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_STAMINA, _theoretical_maximum_base_stamina, 0.0f);
  }
  float theoretical_maximum_base_vitality() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_VITALITY, 0.0f);
  }
  bool mutate_theoretical_maximum_base_vitality(float _theoretical_maximum_base_vitality = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_VITALITY, _theoretical_maximum_base_vitality, 0.0f);
  }
  float theoretical_maximum_base_weight() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_BASE_WEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_base_weight(float _theoretical_maximum_base_weight = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_BASE_WEIGHT, _theoretical_maximum_base_weight, 0.0f);
  }
  float theoretical_maximum_height() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_height(float _theoretical_maximum_height = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT, _theoretical_maximum_height, 0.0f);
  }
  float theoretical_maximum_speed() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_SPEED, 0.0f);
  }
  bool mutate_theoretical_maximum_speed(float _theoretical_maximum_speed = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_SPEED, _theoretical_maximum_speed, 0.0f);
  }
  float theoretical_maximum_weight() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT, 0.0f);
  }
  bool mutate_theoretical_maximum_weight(float _theoretical_maximum_weight = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT, _theoretical_maximum_weight, 0.0f);
  }
  float theoretical_maximum_height_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_height_multiplier(float _theoretical_maximum_height_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER, _theoretical_maximum_height_multiplier, 0.0f);
  }
  float theoretical_maximum_speed_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_speed_multiplier(float _theoretical_maximum_speed_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER, _theoretical_maximum_speed_multiplier, 0.0f);
  }
  float theoretical_maximum_stamina_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_stamina_multiplier(float _theoretical_maximum_stamina_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER, _theoretical_maximum_stamina_multiplier, 0.0f);
  }
  float theoretical_maximum_vitality_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_vitality_multiplier(float _theoretical_maximum_vitality_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER, _theoretical_maximum_vitality_multiplier, 0.0f);
  }
  float theoretical_maximum_weight_multiplier() const {
    return GetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_theoretical_maximum_weight_multiplier(float _theoretical_maximum_weight_multiplier = 0.0f) {
    return SetField<float>(VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER, _theoretical_maximum_weight_multiplier, 0.0f);
  }
  ///  Fixed for an organism
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Organism *o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  const flatbuffers::Vector<uint8_t> *chromosome() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CHROMOSOME);
  }
  flatbuffers::Vector<uint8_t> *mutable_chromosome() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CHROMOSOME);
  }
  Ecosystem::Gender gender() const {
    return static_cast<Ecosystem::Gender>(GetField<uint8_t>(VT_GENDER, 0));
  }
  bool mutate_gender(Ecosystem::Gender _gender = static_cast<Ecosystem::Gender>(0)) {
    return SetField<uint8_t>(VT_GENDER, static_cast<uint8_t>(_gender), 0);
  }
  uint32_t generation() const {
    return GetField<uint32_t>(VT_GENERATION, 0);
  }
  bool mutate_generation(uint32_t _generation = 0) {
    return SetField<uint32_t>(VT_GENERATION, _generation, 0);
  }
  float immunity() const {
    return GetField<float>(VT_IMMUNITY, 0.0f);
  }
  bool mutate_immunity(float _immunity = 0.0f) {
    return SetField<float>(VT_IMMUNITY, _immunity, 0.0f);
  }
  float base_appetite() const {
    return GetField<float>(VT_BASE_APPETITE, 0.0f);
  }
  bool mutate_base_appetite(float _base_appetite = 0.0f) {
    return SetField<float>(VT_BASE_APPETITE, _base_appetite, 0.0f);
  }
  float base_height() const {
    return GetField<float>(VT_BASE_HEIGHT, 0.0f);
  }
  bool mutate_base_height(float _base_height = 0.0f) {
    return SetField<float>(VT_BASE_HEIGHT, _base_height, 0.0f);
  }
  float base_speed() const {
    return GetField<float>(VT_BASE_SPEED, 0.0f);
  }
  bool mutate_base_speed(float _base_speed = 0.0f) {
    return SetField<float>(VT_BASE_SPEED, _base_speed, 0.0f);
  }
  float base_stamina() const {
    return GetField<float>(VT_BASE_STAMINA, 0.0f);
  }
  bool mutate_base_stamina(float _base_stamina = 0.0f) {
    return SetField<float>(VT_BASE_STAMINA, _base_stamina, 0.0f);
  }
  float base_vitality() const {
    return GetField<float>(VT_BASE_VITALITY, 0.0f);
  }
  bool mutate_base_vitality(float _base_vitality = 0.0f) {
    return SetField<float>(VT_BASE_VITALITY, _base_vitality, 0.0f);
  }
  float base_weight() const {
    return GetField<float>(VT_BASE_WEIGHT, 0.0f);
  }
  bool mutate_base_weight(float _base_weight = 0.0f) {
    return SetField<float>(VT_BASE_WEIGHT, _base_weight, 0.0f);
  }
  float height_multiplier() const {
    return GetField<float>(VT_HEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_height_multiplier(float _height_multiplier = 0.0f) {
    return SetField<float>(VT_HEIGHT_MULTIPLIER, _height_multiplier, 0.0f);
  }
  float speed_multiplier() const {
    return GetField<float>(VT_SPEED_MULTIPLIER, 0.0f);
  }
  bool mutate_speed_multiplier(float _speed_multiplier = 0.0f) {
    return SetField<float>(VT_SPEED_MULTIPLIER, _speed_multiplier, 0.0f);
  }
  float stamina_multiplier() const {
    return GetField<float>(VT_STAMINA_MULTIPLIER, 0.0f);
  }
  bool mutate_stamina_multiplier(float _stamina_multiplier = 0.0f) {
    return SetField<float>(VT_STAMINA_MULTIPLIER, _stamina_multiplier, 0.0f);
  }
  float vitality_multiplier() const {
    return GetField<float>(VT_VITALITY_MULTIPLIER, 0.0f);
  }
  bool mutate_vitality_multiplier(float _vitality_multiplier = 0.0f) {
    return SetField<float>(VT_VITALITY_MULTIPLIER, _vitality_multiplier, 0.0f);
  }
  float weight_multiplier() const {
    return GetField<float>(VT_WEIGHT_MULTIPLIER, 0.0f);
  }
  bool mutate_weight_multiplier(float _weight_multiplier = 0.0f) {
    return SetField<float>(VT_WEIGHT_MULTIPLIER, _weight_multiplier, 0.0f);
  }
  float max_height() const {
    return GetField<float>(VT_MAX_HEIGHT, 0.0f);
  }
  bool mutate_max_height(float _max_height = 0.0f) {
    return SetField<float>(VT_MAX_HEIGHT, _max_height, 0.0f);
  }
  float max_weight() const {
    return GetField<float>(VT_MAX_WEIGHT, 0.0f);
  }
  bool mutate_max_weight(float _max_weight = 0.0f) {
    return SetField<float>(VT_MAX_WEIGHT, _max_weight, 0.0f);
  }
  /// Stats affected by age
  uint32_t age() const {
    return GetField<uint32_t>(VT_AGE, 0);
  }
  bool mutate_age(uint32_t _age = 0) {
    return SetField<uint32_t>(VT_AGE, _age, 0);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  bool mutate_height(float _height = 0.0f) {
    return SetField<float>(VT_HEIGHT, _height, 0.0f);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool mutate_weight(float _weight = 0.0f) {
    return SetField<float>(VT_WEIGHT, _weight, 0.0f);
  }
  float static_fitness() const {
    return GetField<float>(VT_STATIC_FITNESS, 0.0f);
  }
  bool mutate_static_fitness(float _static_fitness = 0.0f) {
    return SetField<float>(VT_STATIC_FITNESS, _static_fitness, 0.0f);
  }
  float max_appetite_at_age() const {
    return GetField<float>(VT_MAX_APPETITE_AT_AGE, 0.0f);
  }
  bool mutate_max_appetite_at_age(float _max_appetite_at_age = 0.0f) {
    return SetField<float>(VT_MAX_APPETITE_AT_AGE, _max_appetite_at_age, 0.0f);
  }
  float max_speed_at_age() const {
    return GetField<float>(VT_MAX_SPEED_AT_AGE, 0.0f);
  }
  bool mutate_max_speed_at_age(float _max_speed_at_age = 0.0f) {
    return SetField<float>(VT_MAX_SPEED_AT_AGE, _max_speed_at_age, 0.0f);
  }
  float max_stamina_at_age() const {
    return GetField<float>(VT_MAX_STAMINA_AT_AGE, 0.0f);
  }
  bool mutate_max_stamina_at_age(float _max_stamina_at_age = 0.0f) {
    return SetField<float>(VT_MAX_STAMINA_AT_AGE, _max_stamina_at_age, 0.0f);
  }
  float max_vitality_at_age() const {
    return GetField<float>(VT_MAX_VITALITY_AT_AGE, 0.0f);
  }
  bool mutate_max_vitality_at_age(float _max_vitality_at_age = 0.0f) {
    return SetField<float>(VT_MAX_VITALITY_AT_AGE, _max_vitality_at_age, 0.0f);
  }
  float appetite() const {
    return GetField<float>(VT_APPETITE, 0.0f);
  }
  bool mutate_appetite(float _appetite = 0.0f) {
    return SetField<float>(VT_APPETITE, _appetite, 0.0f);
  }
  float speed() const {
    return GetField<float>(VT_SPEED, 0.0f);
  }
  bool mutate_speed(float _speed = 0.0f) {
    return SetField<float>(VT_SPEED, _speed, 0.0f);
  }
  float stamina() const {
    return GetField<float>(VT_STAMINA, 0.0f);
  }
  bool mutate_stamina(float _stamina = 0.0f) {
    return SetField<float>(VT_STAMINA, _stamina, 0.0f);
  }
  float vitality() const {
    return GetField<float>(VT_VITALITY, 0.0f);
  }
  bool mutate_vitality(float _vitality = 0.0f) {
    return SetField<float>(VT_VITALITY, _vitality, 0.0f);
  }
  uint64_t X() const {
    return GetField<uint64_t>(VT_X, 0);
  }
  bool mutate_X(uint64_t _X = 0) {
    return SetField<uint64_t>(VT_X, _X, 0);
  }
  uint64_t Y() const {
    return GetField<uint64_t>(VT_Y, 0);
  }
  bool mutate_Y(uint64_t _Y = 0) {
    return SetField<uint64_t>(VT_Y, _Y, 0);
  }
  float dynamic_fitness() const {
    return GetField<float>(VT_DYNAMIC_FITNESS, 1.0f);
  }
  bool mutate_dynamic_fitness(float _dynamic_fitness = 1.0f) {
    return SetField<float>(VT_DYNAMIC_FITNESS, _dynamic_fitness, 1.0f);
  }
  /// Miscellaneous attributes
  float vision_radius() const {
    return GetField<float>(VT_VISION_RADIUS, 0.0f);
  }
  bool mutate_vision_radius(float _vision_radius = 0.0f) {
    return SetField<float>(VT_VISION_RADIUS, _vision_radius, 0.0f);
  }
  float sleep_restore_factor() const {
    return GetField<float>(VT_SLEEP_RESTORE_FACTOR, 0.0f);
  }
  bool mutate_sleep_restore_factor(float _sleep_restore_factor = 0.0f) {
    return SetField<float>(VT_SLEEP_RESTORE_FACTOR, _sleep_restore_factor, 0.0f);
  }
  Ecosystem::Sleep asleep() const {
    return static_cast<Ecosystem::Sleep>(GetField<uint8_t>(VT_ASLEEP, 0));
  }
  bool mutate_asleep(Ecosystem::Sleep _asleep = static_cast<Ecosystem::Sleep>(0)) {
    return SetField<uint8_t>(VT_ASLEEP, static_cast<uint8_t>(_asleep), 0);
  }
  Ecosystem::Monitor monitor() const {
    return static_cast<Ecosystem::Monitor>(GetField<uint8_t>(VT_MONITOR, 0));
  }
  bool mutate_monitor(Ecosystem::Monitor _monitor = static_cast<Ecosystem::Monitor>(0)) {
    return SetField<uint8_t>(VT_MONITOR, static_cast<uint8_t>(_monitor), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KIND) &&
           verifier.VerifyString(kind()) &&
           VerifyField<uint8_t>(verifier, VT_KINGDOM, 1) &&
           VerifyField<uint16_t>(verifier, VT_CHROMOSOME_NUMBER, 2) &&
           VerifyOffset(verifier, VT_CHROMOSOME_STRUCTURE) &&
           verifier.VerifyVector(chromosome_structure()) &&
           verifier.VerifyVectorOfTables(chromosome_structure()) &&
           VerifyField<uint8_t>(verifier, VT_FOOD_CHAIN_RANK, 1) &&
           VerifyField<uint8_t>(verifier, VT_SEXUALITY, 1) &&
           VerifyField<float>(verifier, VT_AGE_FITNESS_ON_DEATH_RATIO, 4) &&
           VerifyField<float>(verifier, VT_CONCEIVING_PROBABILITY, 4) &&
           VerifyField<float>(verifier, VT_MATING_PROBABILITY, 4) &&
           VerifyField<uint32_t>(verifier, VT_MATING_AGE_START, 4) &&
           VerifyField<uint32_t>(verifier, VT_MATING_AGE_END, 4) &&
           VerifyField<uint32_t>(verifier, VT_MAX_AGE, 4) &&
           VerifyField<float>(verifier, VT_MUTATION_PROBABILITY, 4) &&
           VerifyField<float>(verifier, VT_OFFSPRINGS_FACTOR, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT_ON_SPEED, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT_ON_STAMINA, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT_ON_VITALITY, 4) &&
           VerifyField<float>(verifier, VT_WEIGHT_ON_SPEED, 4) &&
           VerifyField<float>(verifier, VT_WEIGHT_ON_STAMINA, 4) &&
           VerifyField<float>(verifier, VT_WEIGHT_ON_VITALITY, 4) &&
           VerifyField<float>(verifier, VT_VITALITY_ON_APPETITE, 4) &&
           VerifyField<float>(verifier, VT_VITALITY_ON_SPEED, 4) &&
           VerifyField<float>(verifier, VT_STAMINA_ON_APPETITE, 4) &&
           VerifyField<float>(verifier, VT_STAMINA_ON_SPEED, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_APPETITE, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_SPEED, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_STAMINA, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_VITALITY, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_BASE_WEIGHT, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_SPEED, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_WEIGHT, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER, 4) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CHROMOSOME) &&
           verifier.VerifyVector(chromosome()) &&
           VerifyField<uint8_t>(verifier, VT_GENDER, 1) &&
           VerifyField<uint32_t>(verifier, VT_GENERATION, 4) &&
           VerifyField<float>(verifier, VT_IMMUNITY, 4) &&
           VerifyField<float>(verifier, VT_BASE_APPETITE, 4) &&
           VerifyField<float>(verifier, VT_BASE_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_BASE_SPEED, 4) &&
           VerifyField<float>(verifier, VT_BASE_STAMINA, 4) &&
           VerifyField<float>(verifier, VT_BASE_VITALITY, 4) &&
           VerifyField<float>(verifier, VT_BASE_WEIGHT, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_SPEED_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_STAMINA_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_VITALITY_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_WEIGHT_MULTIPLIER, 4) &&
           VerifyField<float>(verifier, VT_MAX_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_MAX_WEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_AGE, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_WEIGHT, 4) &&
           VerifyField<float>(verifier, VT_STATIC_FITNESS, 4) &&
           VerifyField<float>(verifier, VT_MAX_APPETITE_AT_AGE, 4) &&
           VerifyField<float>(verifier, VT_MAX_SPEED_AT_AGE, 4) &&
           VerifyField<float>(verifier, VT_MAX_STAMINA_AT_AGE, 4) &&
           VerifyField<float>(verifier, VT_MAX_VITALITY_AT_AGE, 4) &&
           VerifyField<float>(verifier, VT_APPETITE, 4) &&
           VerifyField<float>(verifier, VT_SPEED, 4) &&
           VerifyField<float>(verifier, VT_STAMINA, 4) &&
           VerifyField<float>(verifier, VT_VITALITY, 4) &&
           VerifyField<uint64_t>(verifier, VT_X, 8) &&
           VerifyField<uint64_t>(verifier, VT_Y, 8) &&
           VerifyField<float>(verifier, VT_DYNAMIC_FITNESS, 4) &&
           VerifyField<float>(verifier, VT_VISION_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_SLEEP_RESTORE_FACTOR, 4) &&
           VerifyField<uint8_t>(verifier, VT_ASLEEP, 1) &&
           VerifyField<uint8_t>(verifier, VT_MONITOR, 1) &&
           verifier.EndTable();
  }
  OrganismT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OrganismT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Organism> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrganismT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OrganismBuilder {
  typedef Organism Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(flatbuffers::Offset<flatbuffers::String> kind) {
    fbb_.AddOffset(Organism::VT_KIND, kind);
  }
  void add_kingdom(Ecosystem::KingdomE kingdom) {
    fbb_.AddElement<uint8_t>(Organism::VT_KINGDOM, static_cast<uint8_t>(kingdom), 0);
  }
  void add_chromosome_number(uint16_t chromosome_number) {
    fbb_.AddElement<uint16_t>(Organism::VT_CHROMOSOME_NUMBER, chromosome_number, 0);
  }
  void add_chromosome_structure(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>>> chromosome_structure) {
    fbb_.AddOffset(Organism::VT_CHROMOSOME_STRUCTURE, chromosome_structure);
  }
  void add_food_chain_rank(uint8_t food_chain_rank) {
    fbb_.AddElement<uint8_t>(Organism::VT_FOOD_CHAIN_RANK, food_chain_rank, 0);
  }
  void add_sexuality(Ecosystem::Reproduction sexuality) {
    fbb_.AddElement<uint8_t>(Organism::VT_SEXUALITY, static_cast<uint8_t>(sexuality), 0);
  }
  void add_age_fitness_on_death_ratio(float age_fitness_on_death_ratio) {
    fbb_.AddElement<float>(Organism::VT_AGE_FITNESS_ON_DEATH_RATIO, age_fitness_on_death_ratio, 0.0f);
  }
  void add_conceiving_probability(float conceiving_probability) {
    fbb_.AddElement<float>(Organism::VT_CONCEIVING_PROBABILITY, conceiving_probability, 0.0f);
  }
  void add_mating_probability(float mating_probability) {
    fbb_.AddElement<float>(Organism::VT_MATING_PROBABILITY, mating_probability, 0.0f);
  }
  void add_mating_age_start(uint32_t mating_age_start) {
    fbb_.AddElement<uint32_t>(Organism::VT_MATING_AGE_START, mating_age_start, 0);
  }
  void add_mating_age_end(uint32_t mating_age_end) {
    fbb_.AddElement<uint32_t>(Organism::VT_MATING_AGE_END, mating_age_end, 0);
  }
  void add_max_age(uint32_t max_age) {
    fbb_.AddElement<uint32_t>(Organism::VT_MAX_AGE, max_age, 0);
  }
  void add_mutation_probability(float mutation_probability) {
    fbb_.AddElement<float>(Organism::VT_MUTATION_PROBABILITY, mutation_probability, 0.0f);
  }
  void add_offsprings_factor(float offsprings_factor) {
    fbb_.AddElement<float>(Organism::VT_OFFSPRINGS_FACTOR, offsprings_factor, 0.0f);
  }
  void add_height_on_speed(float height_on_speed) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_ON_SPEED, height_on_speed, 0.0f);
  }
  void add_height_on_stamina(float height_on_stamina) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_ON_STAMINA, height_on_stamina, 0.0f);
  }
  void add_height_on_vitality(float height_on_vitality) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_ON_VITALITY, height_on_vitality, 0.0f);
  }
  void add_weight_on_speed(float weight_on_speed) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_ON_SPEED, weight_on_speed, 0.0f);
  }
  void add_weight_on_stamina(float weight_on_stamina) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_ON_STAMINA, weight_on_stamina, 0.0f);
  }
  void add_weight_on_vitality(float weight_on_vitality) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_ON_VITALITY, weight_on_vitality, 0.0f);
  }
  void add_vitality_on_appetite(float vitality_on_appetite) {
    fbb_.AddElement<float>(Organism::VT_VITALITY_ON_APPETITE, vitality_on_appetite, 0.0f);
  }
  void add_vitality_on_speed(float vitality_on_speed) {
    fbb_.AddElement<float>(Organism::VT_VITALITY_ON_SPEED, vitality_on_speed, 0.0f);
  }
  void add_stamina_on_appetite(float stamina_on_appetite) {
    fbb_.AddElement<float>(Organism::VT_STAMINA_ON_APPETITE, stamina_on_appetite, 0.0f);
  }
  void add_stamina_on_speed(float stamina_on_speed) {
    fbb_.AddElement<float>(Organism::VT_STAMINA_ON_SPEED, stamina_on_speed, 0.0f);
  }
  void add_theoretical_maximum_base_appetite(float theoretical_maximum_base_appetite) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_APPETITE, theoretical_maximum_base_appetite, 0.0f);
  }
  void add_theoretical_maximum_base_height(float theoretical_maximum_base_height) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_HEIGHT, theoretical_maximum_base_height, 0.0f);
  }
  void add_theoretical_maximum_base_speed(float theoretical_maximum_base_speed) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_SPEED, theoretical_maximum_base_speed, 0.0f);
  }
  void add_theoretical_maximum_base_stamina(float theoretical_maximum_base_stamina) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_STAMINA, theoretical_maximum_base_stamina, 0.0f);
  }
  void add_theoretical_maximum_base_vitality(float theoretical_maximum_base_vitality) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_VITALITY, theoretical_maximum_base_vitality, 0.0f);
  }
  void add_theoretical_maximum_base_weight(float theoretical_maximum_base_weight) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_BASE_WEIGHT, theoretical_maximum_base_weight, 0.0f);
  }
  void add_theoretical_maximum_height(float theoretical_maximum_height) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_HEIGHT, theoretical_maximum_height, 0.0f);
  }
  void add_theoretical_maximum_speed(float theoretical_maximum_speed) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_SPEED, theoretical_maximum_speed, 0.0f);
  }
  void add_theoretical_maximum_weight(float theoretical_maximum_weight) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_WEIGHT, theoretical_maximum_weight, 0.0f);
  }
  void add_theoretical_maximum_height_multiplier(float theoretical_maximum_height_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_HEIGHT_MULTIPLIER, theoretical_maximum_height_multiplier, 0.0f);
  }
  void add_theoretical_maximum_speed_multiplier(float theoretical_maximum_speed_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_SPEED_MULTIPLIER, theoretical_maximum_speed_multiplier, 0.0f);
  }
  void add_theoretical_maximum_stamina_multiplier(float theoretical_maximum_stamina_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_STAMINA_MULTIPLIER, theoretical_maximum_stamina_multiplier, 0.0f);
  }
  void add_theoretical_maximum_vitality_multiplier(float theoretical_maximum_vitality_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_VITALITY_MULTIPLIER, theoretical_maximum_vitality_multiplier, 0.0f);
  }
  void add_theoretical_maximum_weight_multiplier(float theoretical_maximum_weight_multiplier) {
    fbb_.AddElement<float>(Organism::VT_THEORETICAL_MAXIMUM_WEIGHT_MULTIPLIER, theoretical_maximum_weight_multiplier, 0.0f);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Organism::VT_NAME, name);
  }
  void add_chromosome(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chromosome) {
    fbb_.AddOffset(Organism::VT_CHROMOSOME, chromosome);
  }
  void add_gender(Ecosystem::Gender gender) {
    fbb_.AddElement<uint8_t>(Organism::VT_GENDER, static_cast<uint8_t>(gender), 0);
  }
  void add_generation(uint32_t generation) {
    fbb_.AddElement<uint32_t>(Organism::VT_GENERATION, generation, 0);
  }
  void add_immunity(float immunity) {
    fbb_.AddElement<float>(Organism::VT_IMMUNITY, immunity, 0.0f);
  }
  void add_base_appetite(float base_appetite) {
    fbb_.AddElement<float>(Organism::VT_BASE_APPETITE, base_appetite, 0.0f);
  }
  void add_base_height(float base_height) {
    fbb_.AddElement<float>(Organism::VT_BASE_HEIGHT, base_height, 0.0f);
  }
  void add_base_speed(float base_speed) {
    fbb_.AddElement<float>(Organism::VT_BASE_SPEED, base_speed, 0.0f);
  }
  void add_base_stamina(float base_stamina) {
    fbb_.AddElement<float>(Organism::VT_BASE_STAMINA, base_stamina, 0.0f);
  }
  void add_base_vitality(float base_vitality) {
    fbb_.AddElement<float>(Organism::VT_BASE_VITALITY, base_vitality, 0.0f);
  }
  void add_base_weight(float base_weight) {
    fbb_.AddElement<float>(Organism::VT_BASE_WEIGHT, base_weight, 0.0f);
  }
  void add_height_multiplier(float height_multiplier) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT_MULTIPLIER, height_multiplier, 0.0f);
  }
  void add_speed_multiplier(float speed_multiplier) {
    fbb_.AddElement<float>(Organism::VT_SPEED_MULTIPLIER, speed_multiplier, 0.0f);
  }
  void add_stamina_multiplier(float stamina_multiplier) {
    fbb_.AddElement<float>(Organism::VT_STAMINA_MULTIPLIER, stamina_multiplier, 0.0f);
  }
  void add_vitality_multiplier(float vitality_multiplier) {
    fbb_.AddElement<float>(Organism::VT_VITALITY_MULTIPLIER, vitality_multiplier, 0.0f);
  }
  void add_weight_multiplier(float weight_multiplier) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT_MULTIPLIER, weight_multiplier, 0.0f);
  }
  void add_max_height(float max_height) {
    fbb_.AddElement<float>(Organism::VT_MAX_HEIGHT, max_height, 0.0f);
  }
  void add_max_weight(float max_weight) {
    fbb_.AddElement<float>(Organism::VT_MAX_WEIGHT, max_weight, 0.0f);
  }
  void add_age(uint32_t age) {
    fbb_.AddElement<uint32_t>(Organism::VT_AGE, age, 0);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(Organism::VT_HEIGHT, height, 0.0f);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(Organism::VT_WEIGHT, weight, 0.0f);
  }
  void add_static_fitness(float static_fitness) {
    fbb_.AddElement<float>(Organism::VT_STATIC_FITNESS, static_fitness, 0.0f);
  }
  void add_max_appetite_at_age(float max_appetite_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_APPETITE_AT_AGE, max_appetite_at_age, 0.0f);
  }
  void add_max_speed_at_age(float max_speed_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_SPEED_AT_AGE, max_speed_at_age, 0.0f);
  }
  void add_max_stamina_at_age(float max_stamina_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_STAMINA_AT_AGE, max_stamina_at_age, 0.0f);
  }
  void add_max_vitality_at_age(float max_vitality_at_age) {
    fbb_.AddElement<float>(Organism::VT_MAX_VITALITY_AT_AGE, max_vitality_at_age, 0.0f);
  }
  void add_appetite(float appetite) {
    fbb_.AddElement<float>(Organism::VT_APPETITE, appetite, 0.0f);
  }
  void add_speed(float speed) {
    fbb_.AddElement<float>(Organism::VT_SPEED, speed, 0.0f);
  }
  void add_stamina(float stamina) {
    fbb_.AddElement<float>(Organism::VT_STAMINA, stamina, 0.0f);
  }
  void add_vitality(float vitality) {
    fbb_.AddElement<float>(Organism::VT_VITALITY, vitality, 0.0f);
  }
  void add_X(uint64_t X) {
    fbb_.AddElement<uint64_t>(Organism::VT_X, X, 0);
  }
  void add_Y(uint64_t Y) {
    fbb_.AddElement<uint64_t>(Organism::VT_Y, Y, 0);
  }
  void add_dynamic_fitness(float dynamic_fitness) {
    fbb_.AddElement<float>(Organism::VT_DYNAMIC_FITNESS, dynamic_fitness, 1.0f);
  }
  void add_vision_radius(float vision_radius) {
    fbb_.AddElement<float>(Organism::VT_VISION_RADIUS, vision_radius, 0.0f);
  }
  void add_sleep_restore_factor(float sleep_restore_factor) {
    fbb_.AddElement<float>(Organism::VT_SLEEP_RESTORE_FACTOR, sleep_restore_factor, 0.0f);
  }
  void add_asleep(Ecosystem::Sleep asleep) {
    fbb_.AddElement<uint8_t>(Organism::VT_ASLEEP, static_cast<uint8_t>(asleep), 0);
  }
  void add_monitor(Ecosystem::Monitor monitor) {
    fbb_.AddElement<uint8_t>(Organism::VT_MONITOR, static_cast<uint8_t>(monitor), 0);
  }
  explicit OrganismBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Organism> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Organism>(end);
    fbb_.Required(o, Organism::VT_KIND);
    fbb_.Required(o, Organism::VT_NAME);
    fbb_.Required(o, Organism::VT_CHROMOSOME);
    return o;
  }
};

inline flatbuffers::Offset<Organism> CreateOrganism(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kind = 0,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::animal,
    uint16_t chromosome_number = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>>> chromosome_structure = 0,
    uint8_t food_chain_rank = 0,
    Ecosystem::Reproduction sexuality = Ecosystem::Reproduction::sexual,
    float age_fitness_on_death_ratio = 0.0f,
    float conceiving_probability = 0.0f,
    float mating_probability = 0.0f,
    uint32_t mating_age_start = 0,
    uint32_t mating_age_end = 0,
    uint32_t max_age = 0,
    float mutation_probability = 0.0f,
    float offsprings_factor = 0.0f,
    float height_on_speed = 0.0f,
    float height_on_stamina = 0.0f,
    float height_on_vitality = 0.0f,
    float weight_on_speed = 0.0f,
    float weight_on_stamina = 0.0f,
    float weight_on_vitality = 0.0f,
    float vitality_on_appetite = 0.0f,
    float vitality_on_speed = 0.0f,
    float stamina_on_appetite = 0.0f,
    float stamina_on_speed = 0.0f,
    float theoretical_maximum_base_appetite = 0.0f,
    float theoretical_maximum_base_height = 0.0f,
    float theoretical_maximum_base_speed = 0.0f,
    float theoretical_maximum_base_stamina = 0.0f,
    float theoretical_maximum_base_vitality = 0.0f,
    float theoretical_maximum_base_weight = 0.0f,
    float theoretical_maximum_height = 0.0f,
    float theoretical_maximum_speed = 0.0f,
    float theoretical_maximum_weight = 0.0f,
    float theoretical_maximum_height_multiplier = 0.0f,
    float theoretical_maximum_speed_multiplier = 0.0f,
    float theoretical_maximum_stamina_multiplier = 0.0f,
    float theoretical_maximum_vitality_multiplier = 0.0f,
    float theoretical_maximum_weight_multiplier = 0.0f,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> chromosome = 0,
    Ecosystem::Gender gender = Ecosystem::Gender::male,
    uint32_t generation = 0,
    float immunity = 0.0f,
    float base_appetite = 0.0f,
    float base_height = 0.0f,
    float base_speed = 0.0f,
    float base_stamina = 0.0f,
    float base_vitality = 0.0f,
    float base_weight = 0.0f,
    float height_multiplier = 0.0f,
    float speed_multiplier = 0.0f,
    float stamina_multiplier = 0.0f,
    float vitality_multiplier = 0.0f,
    float weight_multiplier = 0.0f,
    float max_height = 0.0f,
    float max_weight = 0.0f,
    uint32_t age = 0,
    float height = 0.0f,
    float weight = 0.0f,
    float static_fitness = 0.0f,
    float max_appetite_at_age = 0.0f,
    float max_speed_at_age = 0.0f,
    float max_stamina_at_age = 0.0f,
    float max_vitality_at_age = 0.0f,
    float appetite = 0.0f,
    float speed = 0.0f,
    float stamina = 0.0f,
    float vitality = 0.0f,
    uint64_t X = 0,
    uint64_t Y = 0,
    float dynamic_fitness = 1.0f,
    float vision_radius = 0.0f,
    float sleep_restore_factor = 0.0f,
    Ecosystem::Sleep asleep = Ecosystem::Sleep::awake,
    Ecosystem::Monitor monitor = Ecosystem::Monitor::none) {
  OrganismBuilder builder_(_fbb);
  builder_.add_Y(Y);
  builder_.add_X(X);
  builder_.add_sleep_restore_factor(sleep_restore_factor);
  builder_.add_vision_radius(vision_radius);
  builder_.add_dynamic_fitness(dynamic_fitness);
  builder_.add_vitality(vitality);
  builder_.add_stamina(stamina);
  builder_.add_speed(speed);
  builder_.add_appetite(appetite);
  builder_.add_max_vitality_at_age(max_vitality_at_age);
  builder_.add_max_stamina_at_age(max_stamina_at_age);
  builder_.add_max_speed_at_age(max_speed_at_age);
  builder_.add_max_appetite_at_age(max_appetite_at_age);
  builder_.add_static_fitness(static_fitness);
  builder_.add_weight(weight);
  builder_.add_height(height);
  builder_.add_age(age);
  builder_.add_max_weight(max_weight);
  builder_.add_max_height(max_height);
  builder_.add_weight_multiplier(weight_multiplier);
  builder_.add_vitality_multiplier(vitality_multiplier);
  builder_.add_stamina_multiplier(stamina_multiplier);
  builder_.add_speed_multiplier(speed_multiplier);
  builder_.add_height_multiplier(height_multiplier);
  builder_.add_base_weight(base_weight);
  builder_.add_base_vitality(base_vitality);
  builder_.add_base_stamina(base_stamina);
  builder_.add_base_speed(base_speed);
  builder_.add_base_height(base_height);
  builder_.add_base_appetite(base_appetite);
  builder_.add_immunity(immunity);
  builder_.add_generation(generation);
  builder_.add_chromosome(chromosome);
  builder_.add_name(name);
  builder_.add_theoretical_maximum_weight_multiplier(theoretical_maximum_weight_multiplier);
  builder_.add_theoretical_maximum_vitality_multiplier(theoretical_maximum_vitality_multiplier);
  builder_.add_theoretical_maximum_stamina_multiplier(theoretical_maximum_stamina_multiplier);
  builder_.add_theoretical_maximum_speed_multiplier(theoretical_maximum_speed_multiplier);
  builder_.add_theoretical_maximum_height_multiplier(theoretical_maximum_height_multiplier);
  builder_.add_theoretical_maximum_weight(theoretical_maximum_weight);
  builder_.add_theoretical_maximum_speed(theoretical_maximum_speed);
  builder_.add_theoretical_maximum_height(theoretical_maximum_height);
  builder_.add_theoretical_maximum_base_weight(theoretical_maximum_base_weight);
  builder_.add_theoretical_maximum_base_vitality(theoretical_maximum_base_vitality);
  builder_.add_theoretical_maximum_base_stamina(theoretical_maximum_base_stamina);
  builder_.add_theoretical_maximum_base_speed(theoretical_maximum_base_speed);
  builder_.add_theoretical_maximum_base_height(theoretical_maximum_base_height);
  builder_.add_theoretical_maximum_base_appetite(theoretical_maximum_base_appetite);
  builder_.add_stamina_on_speed(stamina_on_speed);
  builder_.add_stamina_on_appetite(stamina_on_appetite);
  builder_.add_vitality_on_speed(vitality_on_speed);
  builder_.add_vitality_on_appetite(vitality_on_appetite);
  builder_.add_weight_on_vitality(weight_on_vitality);
  builder_.add_weight_on_stamina(weight_on_stamina);
  builder_.add_weight_on_speed(weight_on_speed);
  builder_.add_height_on_vitality(height_on_vitality);
  builder_.add_height_on_stamina(height_on_stamina);
  builder_.add_height_on_speed(height_on_speed);
  builder_.add_offsprings_factor(offsprings_factor);
  builder_.add_mutation_probability(mutation_probability);
  builder_.add_max_age(max_age);
  builder_.add_mating_age_end(mating_age_end);
  builder_.add_mating_age_start(mating_age_start);
  builder_.add_mating_probability(mating_probability);
  builder_.add_conceiving_probability(conceiving_probability);
  builder_.add_age_fitness_on_death_ratio(age_fitness_on_death_ratio);
  builder_.add_chromosome_structure(chromosome_structure);
  builder_.add_kind(kind);
  builder_.add_chromosome_number(chromosome_number);
  builder_.add_monitor(monitor);
  builder_.add_asleep(asleep);
  builder_.add_gender(gender);
  builder_.add_sexuality(sexuality);
  builder_.add_food_chain_rank(food_chain_rank);
  builder_.add_kingdom(kingdom);
  return builder_.Finish();
}

struct Organism::Traits {
  using type = Organism;
  static auto constexpr Create = CreateOrganism;
};

inline flatbuffers::Offset<Organism> CreateOrganismDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kind = nullptr,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::animal,
    uint16_t chromosome_number = 0,
    std::vector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> *chromosome_structure = nullptr,
    uint8_t food_chain_rank = 0,
    Ecosystem::Reproduction sexuality = Ecosystem::Reproduction::sexual,
    float age_fitness_on_death_ratio = 0.0f,
    float conceiving_probability = 0.0f,
    float mating_probability = 0.0f,
    uint32_t mating_age_start = 0,
    uint32_t mating_age_end = 0,
    uint32_t max_age = 0,
    float mutation_probability = 0.0f,
    float offsprings_factor = 0.0f,
    float height_on_speed = 0.0f,
    float height_on_stamina = 0.0f,
    float height_on_vitality = 0.0f,
    float weight_on_speed = 0.0f,
    float weight_on_stamina = 0.0f,
    float weight_on_vitality = 0.0f,
    float vitality_on_appetite = 0.0f,
    float vitality_on_speed = 0.0f,
    float stamina_on_appetite = 0.0f,
    float stamina_on_speed = 0.0f,
    float theoretical_maximum_base_appetite = 0.0f,
    float theoretical_maximum_base_height = 0.0f,
    float theoretical_maximum_base_speed = 0.0f,
    float theoretical_maximum_base_stamina = 0.0f,
    float theoretical_maximum_base_vitality = 0.0f,
    float theoretical_maximum_base_weight = 0.0f,
    float theoretical_maximum_height = 0.0f,
    float theoretical_maximum_speed = 0.0f,
    float theoretical_maximum_weight = 0.0f,
    float theoretical_maximum_height_multiplier = 0.0f,
    float theoretical_maximum_speed_multiplier = 0.0f,
    float theoretical_maximum_stamina_multiplier = 0.0f,
    float theoretical_maximum_vitality_multiplier = 0.0f,
    float theoretical_maximum_weight_multiplier = 0.0f,
    const char *name = nullptr,
    const std::vector<uint8_t> *chromosome = nullptr,
    Ecosystem::Gender gender = Ecosystem::Gender::male,
    uint32_t generation = 0,
    float immunity = 0.0f,
    float base_appetite = 0.0f,
    float base_height = 0.0f,
    float base_speed = 0.0f,
    float base_stamina = 0.0f,
    float base_vitality = 0.0f,
    float base_weight = 0.0f,
    float height_multiplier = 0.0f,
    float speed_multiplier = 0.0f,
    float stamina_multiplier = 0.0f,
    float vitality_multiplier = 0.0f,
    float weight_multiplier = 0.0f,
    float max_height = 0.0f,
    float max_weight = 0.0f,
    uint32_t age = 0,
    float height = 0.0f,
    float weight = 0.0f,
    float static_fitness = 0.0f,
    float max_appetite_at_age = 0.0f,
    float max_speed_at_age = 0.0f,
    float max_stamina_at_age = 0.0f,
    float max_vitality_at_age = 0.0f,
    float appetite = 0.0f,
    float speed = 0.0f,
    float stamina = 0.0f,
    float vitality = 0.0f,
    uint64_t X = 0,
    uint64_t Y = 0,
    float dynamic_fitness = 1.0f,
    float vision_radius = 0.0f,
    float sleep_restore_factor = 0.0f,
    Ecosystem::Sleep asleep = Ecosystem::Sleep::awake,
    Ecosystem::Monitor monitor = Ecosystem::Monitor::none) {
  auto kind__ = kind ? _fbb.CreateString(kind) : 0;
  auto chromosome_structure__ = chromosome_structure ? _fbb.CreateVectorOfSortedTables<Ecosystem::ChromosomeStrand>(chromosome_structure) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto chromosome__ = chromosome ? _fbb.CreateVector<uint8_t>(*chromosome) : 0;
  return Ecosystem::CreateOrganism(
      _fbb,
      kind__,
      kingdom,
      chromosome_number,
      chromosome_structure__,
      food_chain_rank,
      sexuality,
      age_fitness_on_death_ratio,
      conceiving_probability,
      mating_probability,
      mating_age_start,
      mating_age_end,
      max_age,
      mutation_probability,
      offsprings_factor,
      height_on_speed,
      height_on_stamina,
      height_on_vitality,
      weight_on_speed,
      weight_on_stamina,
      weight_on_vitality,
      vitality_on_appetite,
      vitality_on_speed,
      stamina_on_appetite,
      stamina_on_speed,
      theoretical_maximum_base_appetite,
      theoretical_maximum_base_height,
      theoretical_maximum_base_speed,
      theoretical_maximum_base_stamina,
      theoretical_maximum_base_vitality,
      theoretical_maximum_base_weight,
      theoretical_maximum_height,
      theoretical_maximum_speed,
      theoretical_maximum_weight,
      theoretical_maximum_height_multiplier,
      theoretical_maximum_speed_multiplier,
      theoretical_maximum_stamina_multiplier,
      theoretical_maximum_vitality_multiplier,
      theoretical_maximum_weight_multiplier,
      name__,
      chromosome__,
      gender,
      generation,
      immunity,
      base_appetite,
      base_height,
      base_speed,
      base_stamina,
      base_vitality,
      base_weight,
      height_multiplier,
      speed_multiplier,
      stamina_multiplier,
      vitality_multiplier,
      weight_multiplier,
      max_height,
      max_weight,
      age,
      height,
      weight,
      static_fitness,
      max_appetite_at_age,
      max_speed_at_age,
      max_stamina_at_age,
      max_vitality_at_age,
      appetite,
      speed,
      stamina,
      vitality,
      X,
      Y,
      dynamic_fitness,
      vision_radius,
      sleep_restore_factor,
      asleep,
      monitor);
}

flatbuffers::Offset<Organism> CreateOrganism(flatbuffers::FlatBufferBuilder &_fbb, const OrganismT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpeciesT : public flatbuffers::NativeTable {
  typedef Species TableType;
  std::string kind{};
  Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::animal;
  std::vector<std::unique_ptr<Ecosystem::OrganismT>> organism{};
  SpeciesT() = default;
  SpeciesT(const SpeciesT &o);
  SpeciesT(SpeciesT&&) FLATBUFFERS_NOEXCEPT = default;
  SpeciesT &operator=(SpeciesT o) FLATBUFFERS_NOEXCEPT;
};

struct Species FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpeciesT NativeTableType;
  typedef SpeciesBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SpeciesTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KIND = 4,
    VT_KINGDOM = 6,
    VT_ORGANISM = 8
  };
  const flatbuffers::String *kind() const {
    return GetPointer<const flatbuffers::String *>(VT_KIND);
  }
  flatbuffers::String *mutable_kind() {
    return GetPointer<flatbuffers::String *>(VT_KIND);
  }
  bool KeyCompareLessThan(const Species *o) const {
    return *kind() < *o->kind();
  }
  int KeyCompareWithValue(const char *_kind) const {
    return strcmp(kind()->c_str(), _kind);
  }
  Ecosystem::KingdomE kingdom() const {
    return static_cast<Ecosystem::KingdomE>(GetField<uint8_t>(VT_KINGDOM, 0));
  }
  bool mutate_kingdom(Ecosystem::KingdomE _kingdom = static_cast<Ecosystem::KingdomE>(0)) {
    return SetField<uint8_t>(VT_KINGDOM, static_cast<uint8_t>(_kingdom), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *organism() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *>(VT_ORGANISM);
  }
  flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *mutable_organism() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>> *>(VT_ORGANISM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KIND) &&
           verifier.VerifyString(kind()) &&
           VerifyField<uint8_t>(verifier, VT_KINGDOM, 1) &&
           VerifyOffset(verifier, VT_ORGANISM) &&
           verifier.VerifyVector(organism()) &&
           verifier.VerifyVectorOfTables(organism()) &&
           verifier.EndTable();
  }
  SpeciesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpeciesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Species> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpeciesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpeciesBuilder {
  typedef Species Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kind(flatbuffers::Offset<flatbuffers::String> kind) {
    fbb_.AddOffset(Species::VT_KIND, kind);
  }
  void add_kingdom(Ecosystem::KingdomE kingdom) {
    fbb_.AddElement<uint8_t>(Species::VT_KINGDOM, static_cast<uint8_t>(kingdom), 0);
  }
  void add_organism(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>>> organism) {
    fbb_.AddOffset(Species::VT_ORGANISM, organism);
  }
  explicit SpeciesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Species> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Species>(end);
    fbb_.Required(o, Species::VT_KIND);
    return o;
  }
};

inline flatbuffers::Offset<Species> CreateSpecies(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kind = 0,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::animal,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Organism>>> organism = 0) {
  SpeciesBuilder builder_(_fbb);
  builder_.add_organism(organism);
  builder_.add_kind(kind);
  builder_.add_kingdom(kingdom);
  return builder_.Finish();
}

struct Species::Traits {
  using type = Species;
  static auto constexpr Create = CreateSpecies;
};

inline flatbuffers::Offset<Species> CreateSpeciesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kind = nullptr,
    Ecosystem::KingdomE kingdom = Ecosystem::KingdomE::animal,
    std::vector<flatbuffers::Offset<Ecosystem::Organism>> *organism = nullptr) {
  auto kind__ = kind ? _fbb.CreateString(kind) : 0;
  auto organism__ = organism ? _fbb.CreateVectorOfSortedTables<Ecosystem::Organism>(organism) : 0;
  return Ecosystem::CreateSpecies(
      _fbb,
      kind__,
      kingdom,
      organism__);
}

flatbuffers::Offset<Species> CreateSpecies(flatbuffers::FlatBufferBuilder &_fbb, const SpeciesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WorldT : public flatbuffers::NativeTable {
  typedef World TableType;
  uint32_t year = 0;
  std::vector<std::unique_ptr<Ecosystem::SpeciesT>> species{};
  WorldT() = default;
  WorldT(const WorldT &o);
  WorldT(WorldT&&) FLATBUFFERS_NOEXCEPT = default;
  WorldT &operator=(WorldT o) FLATBUFFERS_NOEXCEPT;
};

struct World FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WorldT NativeTableType;
  typedef WorldBuilder Builder;
  struct Traits;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return WorldTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_YEAR = 4,
    VT_SPECIES = 6
  };
  uint32_t year() const {
    return GetField<uint32_t>(VT_YEAR, 0);
  }
  bool mutate_year(uint32_t _year = 0) {
    return SetField<uint32_t>(VT_YEAR, _year, 0);
  }
  bool KeyCompareLessThan(const World *o) const {
    return year() < o->year();
  }
  int KeyCompareWithValue(uint32_t _year) const {
    return static_cast<int>(year() > _year) - static_cast<int>(year() < _year);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *species() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *>(VT_SPECIES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *mutable_species() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>> *>(VT_SPECIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_YEAR, 4) &&
           VerifyOffset(verifier, VT_SPECIES) &&
           verifier.VerifyVector(species()) &&
           verifier.VerifyVectorOfTables(species()) &&
           verifier.EndTable();
  }
  WorldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WorldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<World> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WorldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WorldBuilder {
  typedef World Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_year(uint32_t year) {
    fbb_.AddElement<uint32_t>(World::VT_YEAR, year, 0);
  }
  void add_species(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>>> species) {
    fbb_.AddOffset(World::VT_SPECIES, species);
  }
  explicit WorldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<World> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<World>(end);
    return o;
  }
};

inline flatbuffers::Offset<World> CreateWorld(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t year = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ecosystem::Species>>> species = 0) {
  WorldBuilder builder_(_fbb);
  builder_.add_species(species);
  builder_.add_year(year);
  return builder_.Finish();
}

struct World::Traits {
  using type = World;
  static auto constexpr Create = CreateWorld;
};

inline flatbuffers::Offset<World> CreateWorldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t year = 0,
    std::vector<flatbuffers::Offset<Ecosystem::Species>> *species = nullptr) {
  auto species__ = species ? _fbb.CreateVectorOfSortedTables<Ecosystem::Species>(species) : 0;
  return Ecosystem::CreateWorld(
      _fbb,
      year,
      species__);
}

flatbuffers::Offset<World> CreateWorld(flatbuffers::FlatBufferBuilder &_fbb, const WorldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ChromosomeStrandT *ChromosomeStrand::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ChromosomeStrandT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChromosomeStrand::UnPackTo(ChromosomeStrandT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = start(); _o->start = _e; }
  { auto _e = length(); _o->length = _e; }
}

inline flatbuffers::Offset<ChromosomeStrand> ChromosomeStrand::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChromosomeStrandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChromosomeStrand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ChromosomeStrand> CreateChromosomeStrand(flatbuffers::FlatBufferBuilder &_fbb, const ChromosomeStrandT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ChromosomeStrandT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _fbb.CreateString(_o->code);
  auto _start = _o->start;
  auto _length = _o->length;
  return Ecosystem::CreateChromosomeStrand(
      _fbb,
      _code,
      _start,
      _length);
}

inline OrganismT::OrganismT(const OrganismT &o)
      : kind(o.kind),
        kingdom(o.kingdom),
        chromosome_number(o.chromosome_number),
        food_chain_rank(o.food_chain_rank),
        sexuality(o.sexuality),
        age_fitness_on_death_ratio(o.age_fitness_on_death_ratio),
        conceiving_probability(o.conceiving_probability),
        mating_probability(o.mating_probability),
        mating_age_start(o.mating_age_start),
        mating_age_end(o.mating_age_end),
        max_age(o.max_age),
        mutation_probability(o.mutation_probability),
        offsprings_factor(o.offsprings_factor),
        height_on_speed(o.height_on_speed),
        height_on_stamina(o.height_on_stamina),
        height_on_vitality(o.height_on_vitality),
        weight_on_speed(o.weight_on_speed),
        weight_on_stamina(o.weight_on_stamina),
        weight_on_vitality(o.weight_on_vitality),
        vitality_on_appetite(o.vitality_on_appetite),
        vitality_on_speed(o.vitality_on_speed),
        stamina_on_appetite(o.stamina_on_appetite),
        stamina_on_speed(o.stamina_on_speed),
        theoretical_maximum_base_appetite(o.theoretical_maximum_base_appetite),
        theoretical_maximum_base_height(o.theoretical_maximum_base_height),
        theoretical_maximum_base_speed(o.theoretical_maximum_base_speed),
        theoretical_maximum_base_stamina(o.theoretical_maximum_base_stamina),
        theoretical_maximum_base_vitality(o.theoretical_maximum_base_vitality),
        theoretical_maximum_base_weight(o.theoretical_maximum_base_weight),
        theoretical_maximum_height(o.theoretical_maximum_height),
        theoretical_maximum_speed(o.theoretical_maximum_speed),
        theoretical_maximum_weight(o.theoretical_maximum_weight),
        theoretical_maximum_height_multiplier(o.theoretical_maximum_height_multiplier),
        theoretical_maximum_speed_multiplier(o.theoretical_maximum_speed_multiplier),
        theoretical_maximum_stamina_multiplier(o.theoretical_maximum_stamina_multiplier),
        theoretical_maximum_vitality_multiplier(o.theoretical_maximum_vitality_multiplier),
        theoretical_maximum_weight_multiplier(o.theoretical_maximum_weight_multiplier),
        name(o.name),
        chromosome(o.chromosome),
        gender(o.gender),
        generation(o.generation),
        immunity(o.immunity),
        base_appetite(o.base_appetite),
        base_height(o.base_height),
        base_speed(o.base_speed),
        base_stamina(o.base_stamina),
        base_vitality(o.base_vitality),
        base_weight(o.base_weight),
        height_multiplier(o.height_multiplier),
        speed_multiplier(o.speed_multiplier),
        stamina_multiplier(o.stamina_multiplier),
        vitality_multiplier(o.vitality_multiplier),
        weight_multiplier(o.weight_multiplier),
        max_height(o.max_height),
        max_weight(o.max_weight),
        age(o.age),
        height(o.height),
        weight(o.weight),
        static_fitness(o.static_fitness),
        max_appetite_at_age(o.max_appetite_at_age),
        max_speed_at_age(o.max_speed_at_age),
        max_stamina_at_age(o.max_stamina_at_age),
        max_vitality_at_age(o.max_vitality_at_age),
        appetite(o.appetite),
        speed(o.speed),
        stamina(o.stamina),
        vitality(o.vitality),
        X(o.X),
        Y(o.Y),
        dynamic_fitness(o.dynamic_fitness),
        vision_radius(o.vision_radius),
        sleep_restore_factor(o.sleep_restore_factor),
        asleep(o.asleep),
        monitor(o.monitor) {
  chromosome_structure.reserve(o.chromosome_structure.size());
  for (const auto &chromosome_structure_ : o.chromosome_structure) { chromosome_structure.emplace_back((chromosome_structure_) ? new Ecosystem::ChromosomeStrandT(*chromosome_structure_) : nullptr); }
}

inline OrganismT &OrganismT::operator=(OrganismT o) FLATBUFFERS_NOEXCEPT {
  std::swap(kind, o.kind);
  std::swap(kingdom, o.kingdom);
  std::swap(chromosome_number, o.chromosome_number);
  std::swap(chromosome_structure, o.chromosome_structure);
  std::swap(food_chain_rank, o.food_chain_rank);
  std::swap(sexuality, o.sexuality);
  std::swap(age_fitness_on_death_ratio, o.age_fitness_on_death_ratio);
  std::swap(conceiving_probability, o.conceiving_probability);
  std::swap(mating_probability, o.mating_probability);
  std::swap(mating_age_start, o.mating_age_start);
  std::swap(mating_age_end, o.mating_age_end);
  std::swap(max_age, o.max_age);
  std::swap(mutation_probability, o.mutation_probability);
  std::swap(offsprings_factor, o.offsprings_factor);
  std::swap(height_on_speed, o.height_on_speed);
  std::swap(height_on_stamina, o.height_on_stamina);
  std::swap(height_on_vitality, o.height_on_vitality);
  std::swap(weight_on_speed, o.weight_on_speed);
  std::swap(weight_on_stamina, o.weight_on_stamina);
  std::swap(weight_on_vitality, o.weight_on_vitality);
  std::swap(vitality_on_appetite, o.vitality_on_appetite);
  std::swap(vitality_on_speed, o.vitality_on_speed);
  std::swap(stamina_on_appetite, o.stamina_on_appetite);
  std::swap(stamina_on_speed, o.stamina_on_speed);
  std::swap(theoretical_maximum_base_appetite, o.theoretical_maximum_base_appetite);
  std::swap(theoretical_maximum_base_height, o.theoretical_maximum_base_height);
  std::swap(theoretical_maximum_base_speed, o.theoretical_maximum_base_speed);
  std::swap(theoretical_maximum_base_stamina, o.theoretical_maximum_base_stamina);
  std::swap(theoretical_maximum_base_vitality, o.theoretical_maximum_base_vitality);
  std::swap(theoretical_maximum_base_weight, o.theoretical_maximum_base_weight);
  std::swap(theoretical_maximum_height, o.theoretical_maximum_height);
  std::swap(theoretical_maximum_speed, o.theoretical_maximum_speed);
  std::swap(theoretical_maximum_weight, o.theoretical_maximum_weight);
  std::swap(theoretical_maximum_height_multiplier, o.theoretical_maximum_height_multiplier);
  std::swap(theoretical_maximum_speed_multiplier, o.theoretical_maximum_speed_multiplier);
  std::swap(theoretical_maximum_stamina_multiplier, o.theoretical_maximum_stamina_multiplier);
  std::swap(theoretical_maximum_vitality_multiplier, o.theoretical_maximum_vitality_multiplier);
  std::swap(theoretical_maximum_weight_multiplier, o.theoretical_maximum_weight_multiplier);
  std::swap(name, o.name);
  std::swap(chromosome, o.chromosome);
  std::swap(gender, o.gender);
  std::swap(generation, o.generation);
  std::swap(immunity, o.immunity);
  std::swap(base_appetite, o.base_appetite);
  std::swap(base_height, o.base_height);
  std::swap(base_speed, o.base_speed);
  std::swap(base_stamina, o.base_stamina);
  std::swap(base_vitality, o.base_vitality);
  std::swap(base_weight, o.base_weight);
  std::swap(height_multiplier, o.height_multiplier);
  std::swap(speed_multiplier, o.speed_multiplier);
  std::swap(stamina_multiplier, o.stamina_multiplier);
  std::swap(vitality_multiplier, o.vitality_multiplier);
  std::swap(weight_multiplier, o.weight_multiplier);
  std::swap(max_height, o.max_height);
  std::swap(max_weight, o.max_weight);
  std::swap(age, o.age);
  std::swap(height, o.height);
  std::swap(weight, o.weight);
  std::swap(static_fitness, o.static_fitness);
  std::swap(max_appetite_at_age, o.max_appetite_at_age);
  std::swap(max_speed_at_age, o.max_speed_at_age);
  std::swap(max_stamina_at_age, o.max_stamina_at_age);
  std::swap(max_vitality_at_age, o.max_vitality_at_age);
  std::swap(appetite, o.appetite);
  std::swap(speed, o.speed);
  std::swap(stamina, o.stamina);
  std::swap(vitality, o.vitality);
  std::swap(X, o.X);
  std::swap(Y, o.Y);
  std::swap(dynamic_fitness, o.dynamic_fitness);
  std::swap(vision_radius, o.vision_radius);
  std::swap(sleep_restore_factor, o.sleep_restore_factor);
  std::swap(asleep, o.asleep);
  std::swap(monitor, o.monitor);
  return *this;
}

inline OrganismT *Organism::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<OrganismT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Organism::UnPackTo(OrganismT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kind(); if (_e) _o->kind = _e->str(); }
  { auto _e = kingdom(); _o->kingdom = _e; }
  { auto _e = chromosome_number(); _o->chromosome_number = _e; }
  { auto _e = chromosome_structure(); if (_e) { _o->chromosome_structure.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->chromosome_structure[_i]) { _e->Get(_i)->UnPackTo(_o->chromosome_structure[_i].get(), _resolver); } else { _o->chromosome_structure[_i] = std::unique_ptr<Ecosystem::ChromosomeStrandT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->chromosome_structure.resize(0); } }
  { auto _e = food_chain_rank(); _o->food_chain_rank = _e; }
  { auto _e = sexuality(); _o->sexuality = _e; }
  { auto _e = age_fitness_on_death_ratio(); _o->age_fitness_on_death_ratio = _e; }
  { auto _e = conceiving_probability(); _o->conceiving_probability = _e; }
  { auto _e = mating_probability(); _o->mating_probability = _e; }
  { auto _e = mating_age_start(); _o->mating_age_start = _e; }
  { auto _e = mating_age_end(); _o->mating_age_end = _e; }
  { auto _e = max_age(); _o->max_age = _e; }
  { auto _e = mutation_probability(); _o->mutation_probability = _e; }
  { auto _e = offsprings_factor(); _o->offsprings_factor = _e; }
  { auto _e = height_on_speed(); _o->height_on_speed = _e; }
  { auto _e = height_on_stamina(); _o->height_on_stamina = _e; }
  { auto _e = height_on_vitality(); _o->height_on_vitality = _e; }
  { auto _e = weight_on_speed(); _o->weight_on_speed = _e; }
  { auto _e = weight_on_stamina(); _o->weight_on_stamina = _e; }
  { auto _e = weight_on_vitality(); _o->weight_on_vitality = _e; }
  { auto _e = vitality_on_appetite(); _o->vitality_on_appetite = _e; }
  { auto _e = vitality_on_speed(); _o->vitality_on_speed = _e; }
  { auto _e = stamina_on_appetite(); _o->stamina_on_appetite = _e; }
  { auto _e = stamina_on_speed(); _o->stamina_on_speed = _e; }
  { auto _e = theoretical_maximum_base_appetite(); _o->theoretical_maximum_base_appetite = _e; }
  { auto _e = theoretical_maximum_base_height(); _o->theoretical_maximum_base_height = _e; }
  { auto _e = theoretical_maximum_base_speed(); _o->theoretical_maximum_base_speed = _e; }
  { auto _e = theoretical_maximum_base_stamina(); _o->theoretical_maximum_base_stamina = _e; }
  { auto _e = theoretical_maximum_base_vitality(); _o->theoretical_maximum_base_vitality = _e; }
  { auto _e = theoretical_maximum_base_weight(); _o->theoretical_maximum_base_weight = _e; }
  { auto _e = theoretical_maximum_height(); _o->theoretical_maximum_height = _e; }
  { auto _e = theoretical_maximum_speed(); _o->theoretical_maximum_speed = _e; }
  { auto _e = theoretical_maximum_weight(); _o->theoretical_maximum_weight = _e; }
  { auto _e = theoretical_maximum_height_multiplier(); _o->theoretical_maximum_height_multiplier = _e; }
  { auto _e = theoretical_maximum_speed_multiplier(); _o->theoretical_maximum_speed_multiplier = _e; }
  { auto _e = theoretical_maximum_stamina_multiplier(); _o->theoretical_maximum_stamina_multiplier = _e; }
  { auto _e = theoretical_maximum_vitality_multiplier(); _o->theoretical_maximum_vitality_multiplier = _e; }
  { auto _e = theoretical_maximum_weight_multiplier(); _o->theoretical_maximum_weight_multiplier = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = chromosome(); if (_e) { _o->chromosome.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->chromosome.begin()); } }
  { auto _e = gender(); _o->gender = _e; }
  { auto _e = generation(); _o->generation = _e; }
  { auto _e = immunity(); _o->immunity = _e; }
  { auto _e = base_appetite(); _o->base_appetite = _e; }
  { auto _e = base_height(); _o->base_height = _e; }
  { auto _e = base_speed(); _o->base_speed = _e; }
  { auto _e = base_stamina(); _o->base_stamina = _e; }
  { auto _e = base_vitality(); _o->base_vitality = _e; }
  { auto _e = base_weight(); _o->base_weight = _e; }
  { auto _e = height_multiplier(); _o->height_multiplier = _e; }
  { auto _e = speed_multiplier(); _o->speed_multiplier = _e; }
  { auto _e = stamina_multiplier(); _o->stamina_multiplier = _e; }
  { auto _e = vitality_multiplier(); _o->vitality_multiplier = _e; }
  { auto _e = weight_multiplier(); _o->weight_multiplier = _e; }
  { auto _e = max_height(); _o->max_height = _e; }
  { auto _e = max_weight(); _o->max_weight = _e; }
  { auto _e = age(); _o->age = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = weight(); _o->weight = _e; }
  { auto _e = static_fitness(); _o->static_fitness = _e; }
  { auto _e = max_appetite_at_age(); _o->max_appetite_at_age = _e; }
  { auto _e = max_speed_at_age(); _o->max_speed_at_age = _e; }
  { auto _e = max_stamina_at_age(); _o->max_stamina_at_age = _e; }
  { auto _e = max_vitality_at_age(); _o->max_vitality_at_age = _e; }
  { auto _e = appetite(); _o->appetite = _e; }
  { auto _e = speed(); _o->speed = _e; }
  { auto _e = stamina(); _o->stamina = _e; }
  { auto _e = vitality(); _o->vitality = _e; }
  { auto _e = X(); _o->X = _e; }
  { auto _e = Y(); _o->Y = _e; }
  { auto _e = dynamic_fitness(); _o->dynamic_fitness = _e; }
  { auto _e = vision_radius(); _o->vision_radius = _e; }
  { auto _e = sleep_restore_factor(); _o->sleep_restore_factor = _e; }
  { auto _e = asleep(); _o->asleep = _e; }
  { auto _e = monitor(); _o->monitor = _e; }
}

inline flatbuffers::Offset<Organism> Organism::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrganismT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOrganism(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Organism> CreateOrganism(flatbuffers::FlatBufferBuilder &_fbb, const OrganismT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OrganismT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kind = _fbb.CreateString(_o->kind);
  auto _kingdom = _o->kingdom;
  auto _chromosome_number = _o->chromosome_number;
  auto _chromosome_structure = _o->chromosome_structure.size() ? _fbb.CreateVector<flatbuffers::Offset<Ecosystem::ChromosomeStrand>> (_o->chromosome_structure.size(), [](size_t i, _VectorArgs *__va) { return CreateChromosomeStrand(*__va->__fbb, __va->__o->chromosome_structure[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _food_chain_rank = _o->food_chain_rank;
  auto _sexuality = _o->sexuality;
  auto _age_fitness_on_death_ratio = _o->age_fitness_on_death_ratio;
  auto _conceiving_probability = _o->conceiving_probability;
  auto _mating_probability = _o->mating_probability;
  auto _mating_age_start = _o->mating_age_start;
  auto _mating_age_end = _o->mating_age_end;
  auto _max_age = _o->max_age;
  auto _mutation_probability = _o->mutation_probability;
  auto _offsprings_factor = _o->offsprings_factor;
  auto _height_on_speed = _o->height_on_speed;
  auto _height_on_stamina = _o->height_on_stamina;
  auto _height_on_vitality = _o->height_on_vitality;
  auto _weight_on_speed = _o->weight_on_speed;
  auto _weight_on_stamina = _o->weight_on_stamina;
  auto _weight_on_vitality = _o->weight_on_vitality;
  auto _vitality_on_appetite = _o->vitality_on_appetite;
  auto _vitality_on_speed = _o->vitality_on_speed;
  auto _stamina_on_appetite = _o->stamina_on_appetite;
  auto _stamina_on_speed = _o->stamina_on_speed;
  auto _theoretical_maximum_base_appetite = _o->theoretical_maximum_base_appetite;
  auto _theoretical_maximum_base_height = _o->theoretical_maximum_base_height;
  auto _theoretical_maximum_base_speed = _o->theoretical_maximum_base_speed;
  auto _theoretical_maximum_base_stamina = _o->theoretical_maximum_base_stamina;
  auto _theoretical_maximum_base_vitality = _o->theoretical_maximum_base_vitality;
  auto _theoretical_maximum_base_weight = _o->theoretical_maximum_base_weight;
  auto _theoretical_maximum_height = _o->theoretical_maximum_height;
  auto _theoretical_maximum_speed = _o->theoretical_maximum_speed;
  auto _theoretical_maximum_weight = _o->theoretical_maximum_weight;
  auto _theoretical_maximum_height_multiplier = _o->theoretical_maximum_height_multiplier;
  auto _theoretical_maximum_speed_multiplier = _o->theoretical_maximum_speed_multiplier;
  auto _theoretical_maximum_stamina_multiplier = _o->theoretical_maximum_stamina_multiplier;
  auto _theoretical_maximum_vitality_multiplier = _o->theoretical_maximum_vitality_multiplier;
  auto _theoretical_maximum_weight_multiplier = _o->theoretical_maximum_weight_multiplier;
  auto _name = _fbb.CreateString(_o->name);
  auto _chromosome = _fbb.CreateVector(_o->chromosome);
  auto _gender = _o->gender;
  auto _generation = _o->generation;
  auto _immunity = _o->immunity;
  auto _base_appetite = _o->base_appetite;
  auto _base_height = _o->base_height;
  auto _base_speed = _o->base_speed;
  auto _base_stamina = _o->base_stamina;
  auto _base_vitality = _o->base_vitality;
  auto _base_weight = _o->base_weight;
  auto _height_multiplier = _o->height_multiplier;
  auto _speed_multiplier = _o->speed_multiplier;
  auto _stamina_multiplier = _o->stamina_multiplier;
  auto _vitality_multiplier = _o->vitality_multiplier;
  auto _weight_multiplier = _o->weight_multiplier;
  auto _max_height = _o->max_height;
  auto _max_weight = _o->max_weight;
  auto _age = _o->age;
  auto _height = _o->height;
  auto _weight = _o->weight;
  auto _static_fitness = _o->static_fitness;
  auto _max_appetite_at_age = _o->max_appetite_at_age;
  auto _max_speed_at_age = _o->max_speed_at_age;
  auto _max_stamina_at_age = _o->max_stamina_at_age;
  auto _max_vitality_at_age = _o->max_vitality_at_age;
  auto _appetite = _o->appetite;
  auto _speed = _o->speed;
  auto _stamina = _o->stamina;
  auto _vitality = _o->vitality;
  auto _X = _o->X;
  auto _Y = _o->Y;
  auto _dynamic_fitness = _o->dynamic_fitness;
  auto _vision_radius = _o->vision_radius;
  auto _sleep_restore_factor = _o->sleep_restore_factor;
  auto _asleep = _o->asleep;
  auto _monitor = _o->monitor;
  return Ecosystem::CreateOrganism(
      _fbb,
      _kind,
      _kingdom,
      _chromosome_number,
      _chromosome_structure,
      _food_chain_rank,
      _sexuality,
      _age_fitness_on_death_ratio,
      _conceiving_probability,
      _mating_probability,
      _mating_age_start,
      _mating_age_end,
      _max_age,
      _mutation_probability,
      _offsprings_factor,
      _height_on_speed,
      _height_on_stamina,
      _height_on_vitality,
      _weight_on_speed,
      _weight_on_stamina,
      _weight_on_vitality,
      _vitality_on_appetite,
      _vitality_on_speed,
      _stamina_on_appetite,
      _stamina_on_speed,
      _theoretical_maximum_base_appetite,
      _theoretical_maximum_base_height,
      _theoretical_maximum_base_speed,
      _theoretical_maximum_base_stamina,
      _theoretical_maximum_base_vitality,
      _theoretical_maximum_base_weight,
      _theoretical_maximum_height,
      _theoretical_maximum_speed,
      _theoretical_maximum_weight,
      _theoretical_maximum_height_multiplier,
      _theoretical_maximum_speed_multiplier,
      _theoretical_maximum_stamina_multiplier,
      _theoretical_maximum_vitality_multiplier,
      _theoretical_maximum_weight_multiplier,
      _name,
      _chromosome,
      _gender,
      _generation,
      _immunity,
      _base_appetite,
      _base_height,
      _base_speed,
      _base_stamina,
      _base_vitality,
      _base_weight,
      _height_multiplier,
      _speed_multiplier,
      _stamina_multiplier,
      _vitality_multiplier,
      _weight_multiplier,
      _max_height,
      _max_weight,
      _age,
      _height,
      _weight,
      _static_fitness,
      _max_appetite_at_age,
      _max_speed_at_age,
      _max_stamina_at_age,
      _max_vitality_at_age,
      _appetite,
      _speed,
      _stamina,
      _vitality,
      _X,
      _Y,
      _dynamic_fitness,
      _vision_radius,
      _sleep_restore_factor,
      _asleep,
      _monitor);
}

inline SpeciesT::SpeciesT(const SpeciesT &o)
      : kind(o.kind),
        kingdom(o.kingdom) {
  organism.reserve(o.organism.size());
  for (const auto &organism_ : o.organism) { organism.emplace_back((organism_) ? new Ecosystem::OrganismT(*organism_) : nullptr); }
}

inline SpeciesT &SpeciesT::operator=(SpeciesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(kind, o.kind);
  std::swap(kingdom, o.kingdom);
  std::swap(organism, o.organism);
  return *this;
}

inline SpeciesT *Species::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SpeciesT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Species::UnPackTo(SpeciesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kind(); if (_e) _o->kind = _e->str(); }
  { auto _e = kingdom(); _o->kingdom = _e; }
  { auto _e = organism(); if (_e) { _o->organism.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->organism[_i]) { _e->Get(_i)->UnPackTo(_o->organism[_i].get(), _resolver); } else { _o->organism[_i] = std::unique_ptr<Ecosystem::OrganismT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->organism.resize(0); } }
}

inline flatbuffers::Offset<Species> Species::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SpeciesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpecies(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Species> CreateSpecies(flatbuffers::FlatBufferBuilder &_fbb, const SpeciesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SpeciesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kind = _fbb.CreateString(_o->kind);
  auto _kingdom = _o->kingdom;
  auto _organism = _o->organism.size() ? _fbb.CreateVector<flatbuffers::Offset<Ecosystem::Organism>> (_o->organism.size(), [](size_t i, _VectorArgs *__va) { return CreateOrganism(*__va->__fbb, __va->__o->organism[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Ecosystem::CreateSpecies(
      _fbb,
      _kind,
      _kingdom,
      _organism);
}

inline WorldT::WorldT(const WorldT &o)
      : year(o.year) {
  species.reserve(o.species.size());
  for (const auto &species_ : o.species) { species.emplace_back((species_) ? new Ecosystem::SpeciesT(*species_) : nullptr); }
}

inline WorldT &WorldT::operator=(WorldT o) FLATBUFFERS_NOEXCEPT {
  std::swap(year, o.year);
  std::swap(species, o.species);
  return *this;
}

inline WorldT *World::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<WorldT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void World::UnPackTo(WorldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = year(); _o->year = _e; }
  { auto _e = species(); if (_e) { _o->species.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->species[_i]) { _e->Get(_i)->UnPackTo(_o->species[_i].get(), _resolver); } else { _o->species[_i] = std::unique_ptr<Ecosystem::SpeciesT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->species.resize(0); } }
}

inline flatbuffers::Offset<World> World::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WorldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWorld(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<World> CreateWorld(flatbuffers::FlatBufferBuilder &_fbb, const WorldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WorldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _year = _o->year;
  auto _species = _o->species.size() ? _fbb.CreateVector<flatbuffers::Offset<Ecosystem::Species>> (_o->species.size(), [](size_t i, _VectorArgs *__va) { return CreateSpecies(*__va->__fbb, __va->__o->species[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Ecosystem::CreateWorld(
      _fbb,
      _year,
      _species);
}

inline const flatbuffers::TypeTable *GenderTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::GenderTypeTable
  };
  static const char * const names[] = {
    "male",
    "female"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ReproductionTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::ReproductionTypeTable
  };
  static const char * const names[] = {
    "sexual",
    "asexual"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *MonitorTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::MonitorTypeTable
  };
  static const char * const names[] = {
    "none",
    "simulation"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SleepTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::SleepTypeTable
  };
  static const char * const names[] = {
    "awake",
    "drowsy",
    "asleep"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *KingdomETypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_UCHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::KingdomETypeTable
  };
  static const char * const names[] = {
    "animal",
    "plant"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ChromosomeStrandTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_USHORT, 0, -1 }
  };
  static const char * const names[] = {
    "code",
    "start",
    "length"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OrganismTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_USHORT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_UCHAR, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 2 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 1, -1 },
    { flatbuffers::ET_UCHAR, 0, 3 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_ULONG, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 4 },
    { flatbuffers::ET_UCHAR, 0, 5 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::KingdomETypeTable,
    Ecosystem::ChromosomeStrandTypeTable,
    Ecosystem::ReproductionTypeTable,
    Ecosystem::GenderTypeTable,
    Ecosystem::SleepTypeTable,
    Ecosystem::MonitorTypeTable
  };
  static const char * const names[] = {
    "kind",
    "kingdom",
    "chromosome_number",
    "chromosome_structure",
    "food_chain_rank",
    "sexuality",
    "age_fitness_on_death_ratio",
    "conceiving_probability",
    "mating_probability",
    "mating_age_start",
    "mating_age_end",
    "max_age",
    "mutation_probability",
    "offsprings_factor",
    "height_on_speed",
    "height_on_stamina",
    "height_on_vitality",
    "weight_on_speed",
    "weight_on_stamina",
    "weight_on_vitality",
    "vitality_on_appetite",
    "vitality_on_speed",
    "stamina_on_appetite",
    "stamina_on_speed",
    "theoretical_maximum_base_appetite",
    "theoretical_maximum_base_height",
    "theoretical_maximum_base_speed",
    "theoretical_maximum_base_stamina",
    "theoretical_maximum_base_vitality",
    "theoretical_maximum_base_weight",
    "theoretical_maximum_height",
    "theoretical_maximum_speed",
    "theoretical_maximum_weight",
    "theoretical_maximum_height_multiplier",
    "theoretical_maximum_speed_multiplier",
    "theoretical_maximum_stamina_multiplier",
    "theoretical_maximum_vitality_multiplier",
    "theoretical_maximum_weight_multiplier",
    "name",
    "chromosome",
    "gender",
    "generation",
    "immunity",
    "base_appetite",
    "base_height",
    "base_speed",
    "base_stamina",
    "base_vitality",
    "base_weight",
    "height_multiplier",
    "speed_multiplier",
    "stamina_multiplier",
    "vitality_multiplier",
    "weight_multiplier",
    "max_height",
    "max_weight",
    "age",
    "height",
    "weight",
    "static_fitness",
    "max_appetite_at_age",
    "max_speed_at_age",
    "max_stamina_at_age",
    "max_vitality_at_age",
    "appetite",
    "speed",
    "stamina",
    "vitality",
    "X",
    "Y",
    "dynamic_fitness",
    "vision_radius",
    "sleep_restore_factor",
    "asleep",
    "monitor"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 75, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SpeciesTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_UCHAR, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::KingdomETypeTable,
    Ecosystem::OrganismTypeTable
  };
  static const char * const names[] = {
    "kind",
    "kingdom",
    "organism"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 3, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *WorldTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_UINT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    Ecosystem::SpeciesTypeTable
  };
  static const char * const names[] = {
    "year",
    "species"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const Ecosystem::World *GetWorld(const void *buf) {
  return flatbuffers::GetRoot<Ecosystem::World>(buf);
}

inline const Ecosystem::World *GetSizePrefixedWorld(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Ecosystem::World>(buf);
}

inline World *GetMutableWorld(void *buf) {
  return flatbuffers::GetMutableRoot<World>(buf);
}

inline Ecosystem::World *GetMutableSizePrefixedWorld(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<Ecosystem::World>(buf);
}

inline bool VerifyWorldBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Ecosystem::World>(nullptr);
}

inline bool VerifySizePrefixedWorldBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Ecosystem::World>(nullptr);
}

inline void FinishWorldBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Ecosystem::World> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWorldBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Ecosystem::World> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Ecosystem::WorldT> UnPackWorld(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Ecosystem::WorldT>(GetWorld(buf)->UnPack(res));
}

inline std::unique_ptr<Ecosystem::WorldT> UnPackSizePrefixedWorld(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Ecosystem::WorldT>(GetSizePrefixedWorld(buf)->UnPack(res));
}

}  // namespace Ecosystem

#endif  // FLATBUFFERS_GENERATED_WORLD_ECOSYSTEM_H_
